{"version":3,"file":"tether.esm.min.js","sources":["../../src/js/utils.js","../../src/js/evented.js","../../src/js/utils/classes.js","../../src/js/constraint.js","../../src/js/abutment.js","../../src/js/shift.js","../../src/js/tether.js"],"sourcesContent":["let TetherBase;\nif (typeof TetherBase === 'undefined') {\n  TetherBase = { modules: [] };\n}\n\nlet zeroElement = null;\n\n// Same as native getBoundingClientRect, except it takes into account parent <frame> offsets\n// if the element lies within a nested document (<frame> or <iframe>-like).\nfunction getActualBoundingClientRect(node) {\n  let boundingRect = node.getBoundingClientRect();\n\n  // The original object returned by getBoundingClientRect is immutable, so we clone it\n  // We can't use extend because the properties are not considered part of the object by hasOwnProperty in IE9\n  let rect = {};\n  for (let k in boundingRect) {\n    rect[k] = boundingRect[k];\n  }\n\n  try {\n    if (node.ownerDocument !== document) {\n      let { frameElement } = node.ownerDocument.defaultView;\n      if (frameElement) {\n        let frameRect = getActualBoundingClientRect(frameElement);\n        rect.top += frameRect.top;\n        rect.bottom += frameRect.top;\n        rect.left += frameRect.left;\n        rect.right += frameRect.left;\n      }\n    }\n  } catch(err) {\n    // Ignore \"Access is denied\" in IE11/Edge\n  }\n\n  return rect;\n}\n\nfunction getScrollParents(el) {\n  // In firefox if the el is inside an iframe with display: none; window.getComputedStyle() will return null;\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n  const computedStyle = getComputedStyle(el) || {};\n  const { position } = computedStyle;\n  let parents = [];\n\n  if (position === 'fixed') {\n    return [el];\n  }\n\n  let parent = el;\n  while ((parent = parent.parentNode) && parent && parent.nodeType === 1) {\n    let style;\n    try {\n      style = getComputedStyle(parent);\n    } catch(err) {\n      // Intentionally blank\n    }\n\n    if (typeof style === 'undefined' || style === null) {\n      parents.push(parent);\n      return parents;\n    }\n\n    const { overflow, overflowX, overflowY } = style;\n    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n      if (position !== 'absolute' || ['relative', 'absolute', 'fixed'].indexOf(style.position) >= 0) {\n        parents.push(parent);\n      }\n    }\n  }\n\n  parents.push(el.ownerDocument.body);\n\n  // If the node is within a frame, account for the parent window scroll\n  if (el.ownerDocument !== document) {\n    parents.push(el.ownerDocument.defaultView);\n  }\n\n  return parents;\n}\n\nconst uniqueId = (() => {\n  let id = 0;\n  return () => ++id;\n})();\n\nconst zeroPosCache = {};\nconst getOrigin = () => {\n  // getBoundingClientRect is unfortunately too accurate.  It introduces a pixel or two of\n  // jitter as the user scrolls that messes with our ability to detect if two positions\n  // are equivilant or not.  We place an element at the top left of the page that will\n  // get the same jitter, so we can cancel the two out.\n  let node = zeroElement;\n  if (!node || !document.body.contains(node)) {\n    node = document.createElement('div');\n    node.setAttribute('data-tether-id', uniqueId());\n    extend(node.style, {\n      top: 0,\n      left: 0,\n      position: 'absolute'\n    });\n\n    document.body.appendChild(node);\n\n    zeroElement = node;\n  }\n\n  const id = node.getAttribute('data-tether-id');\n  if (typeof zeroPosCache[id] === 'undefined') {\n    zeroPosCache[id] = getActualBoundingClientRect(node);\n\n    // Clear the cache when this position call is done\n    defer(() => {\n      delete zeroPosCache[id];\n    });\n  }\n\n  return zeroPosCache[id];\n};\n\nfunction removeUtilElements() {\n  if (zeroElement) {\n    document.body.removeChild(zeroElement);\n  }\n  zeroElement = null;\n}\n\nfunction getBounds(el) {\n  let doc;\n  if (el === document) {\n    doc = document;\n    el = document.documentElement;\n  } else {\n    doc = el.ownerDocument;\n  }\n\n  const docEl = doc.documentElement;\n\n  const box = getActualBoundingClientRect(el);\n\n  const origin = getOrigin();\n\n  box.top -= origin.top;\n  box.left -= origin.left;\n\n  if (typeof box.width === 'undefined') {\n    box.width = document.body.scrollWidth - box.left - box.right;\n  }\n  if (typeof box.height === 'undefined') {\n    box.height = document.body.scrollHeight - box.top - box.bottom;\n  }\n\n  box.top = box.top - docEl.clientTop;\n  box.left = box.left - docEl.clientLeft;\n  box.right = doc.body.clientWidth - box.width - box.left;\n  box.bottom = doc.body.clientHeight - box.height - box.top;\n\n  return box;\n}\n\nfunction getOffsetParent(el) {\n  return el.offsetParent || document.documentElement;\n}\n\nlet _scrollBarSize = null;\n\nfunction getScrollBarSize() {\n  if (_scrollBarSize) {\n    return _scrollBarSize;\n  }\n  const inner = document.createElement('div');\n  inner.style.width = '100%';\n  inner.style.height = '200px';\n\n  const outer = document.createElement('div');\n  extend(outer.style, {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    pointerEvents: 'none',\n    visibility: 'hidden',\n    width: '200px',\n    height: '150px',\n    overflow: 'hidden'\n  });\n\n  outer.appendChild(inner);\n\n  document.body.appendChild(outer);\n\n  const widthContained = inner.offsetWidth;\n  outer.style.overflow = 'scroll';\n  let widthScroll = inner.offsetWidth;\n\n  if (widthContained === widthScroll) {\n    widthScroll = outer.clientWidth;\n  }\n\n  document.body.removeChild(outer);\n\n  const width = widthContained - widthScroll;\n\n  _scrollBarSize = { width, height: width };\n  return _scrollBarSize;\n}\n\nfunction extend(out = {}) {\n  const args = [];\n\n  Array.prototype.push.apply(args, arguments);\n\n  args.slice(1).forEach((obj) => {\n    if (obj) {\n      for (let key in obj) {\n        if ({}.hasOwnProperty.call(obj, key)) {\n          out[key] = obj[key];\n        }\n      }\n    }\n  });\n\n  return out;\n}\n\nfunction getClassName(el) {\n  // Can't use just SVGAnimatedString here since nodes within a Frame in IE have\n  // completely separately SVGAnimatedString base classes\n  if (el.className instanceof el.ownerDocument.defaultView.SVGAnimatedString) {\n    return el.className.baseVal;\n  }\n  return el.className;\n}\n\nfunction setClassName(el, className) {\n  el.setAttribute('class', className);\n}\n\nconst deferred = [];\n\nconst defer = (fn) => {\n  deferred.push(fn);\n};\n\nconst flush = () => {\n  let fn;\n  // eslint-disable-next-line\n  while (fn = deferred.pop()) {\n    fn();\n  }\n};\n\nTetherBase.Utils = {\n  getActualBoundingClientRect,\n  getScrollParents,\n  getBounds,\n  getOffsetParent,\n  extend,\n  defer,\n  flush,\n  uniqueId,\n  getScrollBarSize,\n  removeUtilElements\n};\n\nexport default TetherBase;\n","export class Evented {\n  on(event, handler, ctx, once = false) {\n    if (typeof this.bindings === 'undefined') {\n      this.bindings = {};\n    }\n    if (typeof this.bindings[event] === 'undefined') {\n      this.bindings[event] = [];\n    }\n    this.bindings[event].push({ handler, ctx, once });\n\n    return this;\n  }\n\n  once(event, handler, ctx) {\n    return this.on(event, handler, ctx, true);\n  }\n\n  off(event, handler) {\n    if (typeof this.bindings === 'undefined' ||\n      typeof this.bindings[event] === 'undefined') {\n      return this;\n    }\n\n    if (typeof handler === 'undefined') {\n      delete this.bindings[event];\n    } else {\n      let i = 0;\n      while (i < this.bindings[event].length) {\n        if (this.bindings[event][i].handler === handler) {\n          this.bindings[event].splice(i, 1);\n        } else {\n          ++i;\n        }\n      }\n    }\n\n    return this;\n  }\n\n  trigger(event, ...args) {\n    if (typeof this.bindings !== 'undefined' && this.bindings[event]) {\n      let i = 0;\n      while (i < this.bindings[event].length) {\n        const { handler, ctx, once } = this.bindings[event][i];\n\n        let context = ctx;\n        if (typeof context === 'undefined') {\n          context = this;\n        }\n\n        handler.apply(context, args);\n\n        if (once) {\n          this.bindings[event].splice(i, 1);\n        } else {\n          ++i;\n        }\n      }\n    }\n\n    return this;\n  }\n}\n","export function addClass(el, name) {\n  name.split(' ').forEach((cls) => {\n    if (cls.trim()) {\n      el.classList.add(cls);\n    }\n  });\n}\n\nexport function removeClass(el, name) {\n  name.split(' ').forEach((cls) => {\n    if (cls.trim()) {\n      el.classList.remove(cls);\n    }\n  });\n}\n\nexport function updateClasses(el, add, all) {\n  // Of the set of 'all' classes, we need the 'add' classes, and only the\n  // 'add' classes to be set.\n  all.forEach((cls) => {\n    if (add.indexOf(cls) === -1 && el.classList.contains(cls)) {\n      removeClass(el, cls);\n    }\n  });\n\n  add.forEach((cls) => {\n    if (!el.classList.contains(cls)) {\n      addClass(el, cls);\n    }\n  });\n}\n","import TetherBase from './utils';\nimport { updateClasses } from './utils/classes';\n\nconst {\n  getBounds,\n  extend,\n  defer\n} = TetherBase.Utils;\n\nconst BOUNDS_FORMAT = ['left', 'top', 'right', 'bottom'];\n\nfunction getBoundingRect(tether, to) {\n  if (to === 'scrollParent') {\n    to = tether.scrollParents[0];\n  } else if (to === 'window') {\n    to = [pageXOffset, pageYOffset, innerWidth + pageXOffset, innerHeight + pageYOffset];\n  }\n\n  if (to === document) {\n    to = to.documentElement;\n  }\n\n  if (typeof to.nodeType !== 'undefined') {\n    const node = to;\n    const size = getBounds(to);\n    const pos = size;\n    const style = getComputedStyle(to);\n\n    to = [pos.left, pos.top, size.width + pos.left, size.height + pos.top];\n\n    // Account any parent Frames scroll offset\n    if (node.ownerDocument !== document) {\n      let win = node.ownerDocument.defaultView;\n      to[0] += win.pageXOffset;\n      to[1] += win.pageYOffset;\n      to[2] += win.pageXOffset;\n      to[3] += win.pageYOffset;\n    }\n\n    BOUNDS_FORMAT.forEach((side, i) => {\n      side = side[0].toUpperCase() + side.substr(1);\n      if (side === 'Top' || side === 'Left') {\n        to[i] += parseFloat(style[`border${side}Width`]);\n      } else {\n        to[i] -= parseFloat(style[`border${side}Width`]);\n      }\n    });\n  }\n\n  return to;\n}\n\nTetherBase.modules.push({\n  position({ top, left, targetAttachment }) {\n    if (!this.options.constraints) {\n      return true;\n    }\n\n    let { height, width } = this.cache('element-bounds', () => {\n      return getBounds(this.element);\n    });\n\n    if (width === 0 && height === 0 && typeof this.lastSize !== 'undefined') {\n      // Handle the item getting hidden as a result of our positioning without glitching\n      // the classes in and out\n      ({ width, height } = this.lastSize);\n    }\n\n    const targetSize = this.cache('target-bounds', () => {\n      return this.getTargetBounds();\n    });\n\n    const { height: targetHeight, width: targetWidth } = targetSize;\n\n    const allClasses = [this.getClass('pinned'), this.getClass('out-of-bounds')];\n\n    this.options.constraints.forEach((constraint) => {\n      const { outOfBoundsClass, pinnedClass } = constraint;\n      if (outOfBoundsClass) {\n        allClasses.push(outOfBoundsClass);\n      }\n      if (pinnedClass) {\n        allClasses.push(pinnedClass);\n      }\n    });\n\n    allClasses.forEach((cls) => {\n      ['left', 'top', 'right', 'bottom'].forEach((side) => {\n        allClasses.push(`${cls}-${side}`);\n      });\n    });\n\n    const addClasses = [];\n\n    const tAttachment = extend({}, targetAttachment);\n    const eAttachment = extend({}, this.attachment);\n\n    this.options.constraints.forEach((constraint) => {\n      let { to, attachment, pin } = constraint;\n\n      if (typeof attachment === 'undefined') {\n        attachment = '';\n      }\n\n      let changeAttachX, changeAttachY;\n      if (attachment.indexOf(' ') >= 0) {\n        [changeAttachY, changeAttachX] = attachment.split(' ');\n      } else {\n        changeAttachX = changeAttachY = attachment;\n      }\n\n      const bounds = getBoundingRect(this, to);\n\n      if (changeAttachY === 'target' || changeAttachY === 'both') {\n        if (top < bounds[1] && tAttachment.top === 'top') {\n          top += targetHeight;\n          tAttachment.top = 'bottom';\n        }\n\n        if (top + height > bounds[3] && tAttachment.top === 'bottom') {\n          top -= targetHeight;\n          tAttachment.top = 'top';\n        }\n      }\n\n      if (changeAttachY === 'together') {\n        if (tAttachment.top === 'top') {\n          if (eAttachment.top === 'bottom' && top < bounds[1]) {\n            top += targetHeight;\n            tAttachment.top = 'bottom';\n\n            top += height;\n            eAttachment.top = 'top';\n\n          } else if (eAttachment.top === 'top' && top + height > bounds[3] && top - (height - targetHeight) >= bounds[1]) {\n            top -= height - targetHeight;\n            tAttachment.top = 'bottom';\n\n            eAttachment.top = 'bottom';\n          }\n        }\n\n        if (tAttachment.top === 'bottom') {\n          if (eAttachment.top === 'top' && top + height > bounds[3]) {\n            top -= targetHeight;\n            tAttachment.top = 'top';\n\n            top -= height;\n            eAttachment.top = 'bottom';\n\n          } else if (eAttachment.top === 'bottom' && top < bounds[1] && top + (height * 2 - targetHeight) <= bounds[3]) {\n            top += height - targetHeight;\n            tAttachment.top = 'top';\n\n            eAttachment.top = 'top';\n\n          }\n        }\n\n        if (tAttachment.top === 'middle') {\n          if (top + height > bounds[3] && eAttachment.top === 'top') {\n            top -= height;\n            eAttachment.top = 'bottom';\n\n          } else if (top < bounds[1] && eAttachment.top === 'bottom') {\n            top += height;\n            eAttachment.top = 'top';\n          }\n        }\n      }\n\n      if (changeAttachX === 'target' || changeAttachX === 'both') {\n        if (left < bounds[0] && tAttachment.left === 'left') {\n          left += targetWidth;\n          tAttachment.left = 'right';\n        }\n\n        if (left + width > bounds[2] && tAttachment.left === 'right') {\n          left -= targetWidth;\n          tAttachment.left = 'left';\n        }\n      }\n\n      if (changeAttachX === 'together') {\n        if (left < bounds[0] && tAttachment.left === 'left') {\n          if (eAttachment.left === 'right') {\n            left += targetWidth;\n            tAttachment.left = 'right';\n\n            left += width;\n            eAttachment.left = 'left';\n\n          } else if (eAttachment.left === 'left') {\n            left += targetWidth;\n            tAttachment.left = 'right';\n\n            left -= width;\n            eAttachment.left = 'right';\n          }\n\n        } else if (left + width > bounds[2] && tAttachment.left === 'right') {\n          if (eAttachment.left === 'left') {\n            left -= targetWidth;\n            tAttachment.left = 'left';\n\n            left -= width;\n            eAttachment.left = 'right';\n\n          } else if (eAttachment.left === 'right') {\n            left -= targetWidth;\n            tAttachment.left = 'left';\n\n            left += width;\n            eAttachment.left = 'left';\n          }\n\n        } else if (tAttachment.left === 'center') {\n          if (left + width > bounds[2] && eAttachment.left === 'left') {\n            left -= width;\n            eAttachment.left = 'right';\n\n          } else if (left < bounds[0] && eAttachment.left === 'right') {\n            left += width;\n            eAttachment.left = 'left';\n          }\n        }\n      }\n\n      if (changeAttachY === 'element' || changeAttachY === 'both') {\n        if (top < bounds[1] && eAttachment.top === 'bottom') {\n          top += height;\n          eAttachment.top = 'top';\n        }\n\n        if (top + height > bounds[3] && eAttachment.top === 'top') {\n          top -= height;\n          eAttachment.top = 'bottom';\n        }\n      }\n\n      if (changeAttachX === 'element' || changeAttachX === 'both') {\n        if (left < bounds[0]) {\n          if (eAttachment.left === 'right') {\n            left += width;\n            eAttachment.left = 'left';\n          } else if (eAttachment.left === 'center') {\n            left += (width / 2);\n            eAttachment.left = 'left';\n          }\n        }\n\n        if (left + width > bounds[2]) {\n          if (eAttachment.left === 'left') {\n            left -= width;\n            eAttachment.left = 'right';\n          } else if (eAttachment.left === 'center') {\n            left -= (width / 2);\n            eAttachment.left = 'right';\n          }\n        }\n      }\n\n      if (typeof pin === 'string') {\n        pin = pin.split(',').map((p) => p.trim());\n      } else if (pin === true) {\n        pin = ['top', 'left', 'right', 'bottom'];\n      }\n\n      pin = pin || [];\n\n      const pinned = [];\n      const oob = [];\n\n      if (top < bounds[1]) {\n        if (pin.indexOf('top') >= 0) {\n          top = bounds[1];\n          pinned.push('top');\n        } else {\n          oob.push('top');\n        }\n      }\n\n      if (top + height > bounds[3]) {\n        if (pin.indexOf('bottom') >= 0) {\n          top = bounds[3] - height;\n          pinned.push('bottom');\n        } else {\n          oob.push('bottom');\n        }\n      }\n\n      if (left < bounds[0]) {\n        if (pin.indexOf('left') >= 0) {\n          left = bounds[0];\n          pinned.push('left');\n        } else {\n          oob.push('left');\n        }\n      }\n\n      if (left + width > bounds[2]) {\n        if (pin.indexOf('right') >= 0) {\n          left = bounds[2] - width;\n          pinned.push('right');\n        } else {\n          oob.push('right');\n        }\n      }\n\n      if (pinned.length) {\n        let pinnedClass;\n        if (typeof this.options.pinnedClass !== 'undefined') {\n          pinnedClass = this.options.pinnedClass;\n        } else {\n          pinnedClass = this.getClass('pinned');\n        }\n\n        addClasses.push(pinnedClass);\n        pinned.forEach((side) => {\n          addClasses.push(`${pinnedClass}-${side}`);\n        });\n      }\n\n      if (oob.length) {\n        let oobClass;\n        if (typeof this.options.outOfBoundsClass !== 'undefined') {\n          oobClass = this.options.outOfBoundsClass;\n        } else {\n          oobClass = this.getClass('out-of-bounds');\n        }\n\n        addClasses.push(oobClass);\n        oob.forEach((side) => {\n          addClasses.push(`${oobClass}-${side}`);\n        });\n      }\n\n      if (pinned.indexOf('left') >= 0 || pinned.indexOf('right') >= 0) {\n        eAttachment.left = tAttachment.left = false;\n      }\n      if (pinned.indexOf('top') >= 0 || pinned.indexOf('bottom') >= 0) {\n        eAttachment.top = tAttachment.top = false;\n      }\n\n      if (tAttachment.top !== targetAttachment.top ||\n        tAttachment.left !== targetAttachment.left ||\n        eAttachment.top !== this.attachment.top ||\n        eAttachment.left !== this.attachment.left) {\n        this.updateAttachClasses(eAttachment, tAttachment);\n        this.trigger('update', {\n          attachment: eAttachment,\n          targetAttachment: tAttachment\n        });\n      }\n    });\n\n    defer(() => {\n      if (!(this.options.addTargetClasses === false)) {\n        updateClasses(this.target, addClasses, allClasses);\n      }\n      updateClasses(this.element, addClasses, allClasses);\n    });\n\n    return { top, left };\n  }\n});\n","import TetherBase from './utils';\nimport { updateClasses } from './utils/classes';\n\nconst { getBounds, defer } = TetherBase.Utils;\n\nTetherBase.modules.push({\n  position({ top, left }) {\n    const { height, width } = this.cache('element-bounds', () => {\n      return getBounds(this.element);\n    });\n\n    const targetPos = this.getTargetBounds();\n\n    const bottom = top + height;\n    const right = left + width;\n\n    const abutted = [];\n    if (top <= targetPos.bottom && bottom >= targetPos.top) {\n      ['left', 'right'].forEach((side) => {\n        const targetPosSide = targetPos[side];\n        if (targetPosSide === left || targetPosSide === right) {\n          abutted.push(side);\n        }\n      });\n    }\n\n    if (left <= targetPos.right && right >= targetPos.left) {\n      ['top', 'bottom'].forEach((side) => {\n        const targetPosSide = targetPos[side];\n        if (targetPosSide === top || targetPosSide === bottom) {\n          abutted.push(side);\n        }\n      });\n    }\n\n    const allClasses = [];\n    const addClasses = [];\n\n    const sides = ['left', 'top', 'right', 'bottom'];\n    allClasses.push(this.getClass('abutted'));\n    sides.forEach((side) => {\n      allClasses.push(`${this.getClass('abutted')}-${side}`);\n    });\n\n    if (abutted.length) {\n      addClasses.push(this.getClass('abutted'));\n    }\n\n    abutted.forEach((side) => {\n      addClasses.push(`${this.getClass('abutted')}-${side}`);\n    });\n\n    defer(() => {\n      if (!(this.options.addTargetClasses === false)) {\n        updateClasses(this.target, addClasses, allClasses);\n      }\n      updateClasses(this.element, addClasses, allClasses);\n    });\n\n    return true;\n  }\n});\n","import TetherBase from './utils';\n\nTetherBase.modules.push({\n  position({ top, left }) {\n    if (!this.options.shift) {\n      return;\n    }\n\n    let { shift } = this.options;\n    if (typeof shift === 'function') {\n      shift = shift.call(this, { top, left });\n    }\n\n    let shiftTop, shiftLeft;\n    if (typeof shift === 'string') {\n      shift = shift.split(' ');\n      shift[1] = shift[1] || shift[0];\n\n      ([shiftTop, shiftLeft] = shift);\n\n      shiftTop = parseFloat(shiftTop, 10);\n      shiftLeft = parseFloat(shiftLeft, 10);\n    } else {\n      ([shiftTop, shiftLeft] = [shift.top, shift.left]);\n    }\n\n    top += shiftTop;\n    left += shiftLeft;\n\n    return { top, left };\n  }\n});\n","/* globals TetherBase */\n\nimport '../css/tether.scss';\nimport '../css/tether-theme-arrows.scss';\nimport '../css/tether-theme-arrows-dark.scss';\nimport '../css/tether-theme-basic.scss';\nimport { Evented } from './evented';\nimport TetherBase from './utils';\nimport { addClass, removeClass, updateClasses } from './utils/classes';\nimport './constraint';\nimport './abutment';\nimport './shift';\n\nconst {\n  getScrollParents,\n  getBounds,\n  getOffsetParent,\n  extend,\n  defer,\n  flush,\n  getScrollBarSize,\n  removeUtilElements\n} = TetherBase.Utils;\n\nfunction isFullscreenElement(e) {\n  let d = e.ownerDocument;\n  let fe = d.fullscreenElement || d.webkitFullscreenElement || d.mozFullScreenElement || d.msFullscreenElement;\n  return fe === e;\n}\n\nfunction within(a, b, diff = 1) {\n  return (a + diff >= b && b >= a - diff);\n}\n\nconst transformKey = (() => {\n  if (typeof document === 'undefined') {\n    return '';\n  }\n  const el = document.createElement('div');\n\n  const transforms = ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform'];\n  for (let i = 0; i < transforms.length; ++i) {\n    const key = transforms[i];\n    if (el.style[key] !== undefined) {\n      return key;\n    }\n  }\n})();\n\nconst tethers = [];\n\nconst position = () => {\n  tethers.forEach((tether) => {\n    tether.position(false);\n  });\n  flush();\n};\n\nfunction now() {\n  if (typeof performance === 'object' && typeof performance.now === 'function') {\n    return performance.now();\n  }\n  return +new Date;\n}\n\n(() => {\n  let lastCall = null;\n  let lastDuration = null;\n  let pendingTimeout = null;\n\n  const tick = () => {\n    if (typeof lastDuration !== 'undefined' && lastDuration > 16) {\n      // We voluntarily throttle ourselves if we can't manage 60fps\n      lastDuration = Math.min(lastDuration - 16, 250);\n\n      // Just in case this is the last event, remember to position just once more\n      pendingTimeout = setTimeout(tick, 250);\n      return;\n    }\n\n    if (typeof lastCall !== 'undefined' && (now() - lastCall) < 10) {\n      // Some browsers call events a little too frequently, refuse to run more than is reasonable\n      return;\n    }\n\n    if (pendingTimeout != null) {\n      clearTimeout(pendingTimeout);\n      pendingTimeout = null;\n    }\n\n    lastCall = now();\n    position();\n    lastDuration = now() - lastCall;\n  };\n\n  if (typeof window !== 'undefined' && typeof window.addEventListener !== 'undefined') {\n    ['resize', 'scroll', 'touchmove'].forEach((event) => {\n      window.addEventListener(event, tick);\n    });\n  }\n})();\n\nconst MIRROR_LR = {\n  center: 'center',\n  left: 'right',\n  right: 'left'\n};\n\nconst MIRROR_TB = {\n  middle: 'middle',\n  top: 'bottom',\n  bottom: 'top'\n};\n\nconst OFFSET_MAP = {\n  top: 0,\n  left: 0,\n  middle: '50%',\n  center: '50%',\n  bottom: '100%',\n  right: '100%'\n};\n\nconst autoToFixedAttachment = (attachment, relativeToAttachment) => {\n  let { left, top } = attachment;\n\n  if (left === 'auto') {\n    left = MIRROR_LR[relativeToAttachment.left];\n  }\n\n  if (top === 'auto') {\n    top = MIRROR_TB[relativeToAttachment.top];\n  }\n\n  return { left, top };\n};\n\nconst attachmentToOffset = (attachment) => {\n  let { left, top } = attachment;\n\n  if (typeof OFFSET_MAP[attachment.left] !== 'undefined') {\n    left = OFFSET_MAP[attachment.left];\n  }\n\n  if (typeof OFFSET_MAP[attachment.top] !== 'undefined') {\n    top = OFFSET_MAP[attachment.top];\n  }\n\n  return { left, top };\n};\n\nfunction addOffset(...offsets) {\n  const out = { top: 0, left: 0 };\n\n  offsets.forEach(({ top, left }) => {\n    if (typeof top === 'string') {\n      top = parseFloat(top, 10);\n    }\n    if (typeof left === 'string') {\n      left = parseFloat(left, 10);\n    }\n\n    out.top += top;\n    out.left += left;\n  });\n\n  return out;\n}\n\nfunction offsetToPx(offset, size) {\n  if (typeof offset.left === 'string' && offset.left.indexOf('%') !== -1) {\n    offset.left = parseFloat(offset.left, 10) / 100 * size.width;\n  }\n  if (typeof offset.top === 'string' && offset.top.indexOf('%') !== -1) {\n    offset.top = parseFloat(offset.top, 10) / 100 * size.height;\n  }\n\n  return offset;\n}\n\nconst parseOffset = (value) => {\n  const [top, left] = value.split(' ');\n  return { top, left };\n};\nconst parseAttachment = parseOffset;\n\nclass TetherClass extends Evented {\n\n  constructor(options) {\n    super();\n    this.position = this.position.bind(this);\n\n    tethers.push(this);\n\n    this.history = [];\n\n    this.setOptions(options, false);\n\n    TetherBase.modules.forEach((module) => {\n      if (typeof module.initialize !== 'undefined') {\n        module.initialize.call(this);\n      }\n    });\n\n    this.position();\n  }\n\n  getClass(key = '') {\n    const { classes } = this.options;\n    if (typeof classes !== 'undefined' && classes[key]) {\n      return this.options.classes[key];\n    } else if (this.options.classPrefix) {\n      return `${this.options.classPrefix}-${key}`;\n    } else {\n      return key;\n    }\n  }\n\n  setOptions(options, pos = true) {\n    const defaults = {\n      offset: '0 0',\n      targetOffset: '0 0',\n      targetAttachment: 'auto auto',\n      classPrefix: 'tether'\n    };\n\n    this.options = extend(defaults, options);\n\n    let { element, target, targetModifier } = this.options;\n    this.element = element;\n    this.target = target;\n    this.targetModifier = targetModifier;\n\n    if (this.target === 'viewport') {\n      this.target = document.body;\n      this.targetModifier = 'visible';\n    } else if (this.target === 'scroll-handle') {\n      this.target = document.body;\n      this.targetModifier = 'scroll-handle';\n    }\n\n    ['element', 'target'].forEach((key) => {\n      if (typeof this[key] === 'undefined') {\n        throw new Error('Tether Error: Both element and target must be defined');\n      }\n\n      if (typeof this[key].jquery !== 'undefined') {\n        this[key] = this[key][0];\n      } else if (typeof this[key] === 'string') {\n        this[key] = document.querySelector(this[key]);\n      }\n    });\n\n    addClass(this.element, this.getClass('element'));\n    if (!(this.options.addTargetClasses === false)) {\n      addClass(this.target, this.getClass('target'));\n    }\n\n    if (!this.options.attachment) {\n      throw new Error('Tether Error: You must provide an attachment');\n    }\n\n    this.targetAttachment = parseAttachment(this.options.targetAttachment);\n    this.attachment = parseAttachment(this.options.attachment);\n    this.offset = parseOffset(this.options.offset);\n    this.targetOffset = parseOffset(this.options.targetOffset);\n\n    if (typeof this.scrollParents !== 'undefined') {\n      this.disable();\n    }\n\n    if (this.targetModifier === 'scroll-handle') {\n      this.scrollParents = [this.target];\n    } else {\n      this.scrollParents = getScrollParents(this.target);\n    }\n\n    if (!(this.options.enabled === false)) {\n      this.enable(pos);\n    }\n  }\n\n  getTargetBounds() {\n    if (typeof this.targetModifier !== 'undefined') {\n      if (this.targetModifier === 'visible') {\n        if (this.target === document.body) {\n          return { top: pageYOffset, left: pageXOffset, height: innerHeight, width: innerWidth };\n        } else {\n          const bounds = getBounds(this.target);\n\n          const out = {\n            height: bounds.height,\n            width: bounds.width,\n            top: bounds.top,\n            left: bounds.left\n          };\n\n          out.height = Math.min(out.height, bounds.height - (pageYOffset - bounds.top));\n          out.height = Math.min(out.height, bounds.height - ((bounds.top + bounds.height) - (pageYOffset + innerHeight)));\n          out.height = Math.min(innerHeight, out.height);\n          out.height -= 2;\n\n          out.width = Math.min(out.width, bounds.width - (pageXOffset - bounds.left));\n          out.width = Math.min(out.width, bounds.width - ((bounds.left + bounds.width) - (pageXOffset + innerWidth)));\n          out.width = Math.min(innerWidth, out.width);\n          out.width -= 2;\n\n          if (out.top < pageYOffset) {\n            out.top = pageYOffset;\n          }\n          if (out.left < pageXOffset) {\n            out.left = pageXOffset;\n          }\n\n          return out;\n        }\n      } else if (this.targetModifier === 'scroll-handle') {\n        let bounds;\n        let { target } = this;\n        if (target === document.body) {\n          target = document.documentElement;\n\n          bounds = {\n            left: pageXOffset,\n            top: pageYOffset,\n            height: innerHeight,\n            width: innerWidth\n          };\n        } else {\n          bounds = getBounds(target);\n        }\n\n        const style = getComputedStyle(target);\n\n        const hasBottomScroll = (\n          target.scrollWidth > target.clientWidth ||\n          [style.overflow, style.overflowX].indexOf('scroll') >= 0 ||\n          this.target !== document.body\n        );\n\n        let scrollBottom = 0;\n        if (hasBottomScroll) {\n          scrollBottom = 15;\n        }\n\n        const height = bounds.height - parseFloat(style.borderTopWidth) - parseFloat(style.borderBottomWidth) - scrollBottom;\n\n        const out = {\n          width: 15,\n          height: height * 0.975 * (height / target.scrollHeight),\n          left: bounds.left + bounds.width - parseFloat(style.borderLeftWidth) - 15\n        };\n\n        let fitAdj = 0;\n        if (height < 408 && this.target === document.body) {\n          fitAdj = -0.00011 * Math.pow(height, 2) - 0.00727 * height + 22.58;\n        }\n\n        if (this.target !== document.body) {\n          out.height = Math.max(out.height, 24);\n        }\n\n        const scrollPercentage = this.target.scrollTop / (target.scrollHeight - height);\n        out.top = scrollPercentage * (height - out.height - fitAdj) + bounds.top + parseFloat(style.borderTopWidth);\n\n        if (this.target === document.body) {\n          out.height = Math.max(out.height, 24);\n        }\n\n        return out;\n      }\n    } else {\n      return getBounds(this.target);\n    }\n  }\n\n  clearCache() {\n    this._cache = {};\n  }\n\n  cache(k, getter) {\n    // More than one module will often need the same DOM info, so\n    // we keep a cache which is cleared on each position call\n    if (typeof this._cache === 'undefined') {\n      this._cache = {};\n    }\n\n    if (typeof this._cache[k] === 'undefined') {\n      this._cache[k] = getter.call(this);\n    }\n\n    return this._cache[k];\n  }\n\n  enable(pos = true) {\n    if (!(this.options.addTargetClasses === false)) {\n      addClass(this.target, this.getClass('enabled'));\n    }\n    addClass(this.element, this.getClass('enabled'));\n    this.enabled = true;\n\n    this.scrollParents.forEach((parent) => {\n      if (parent !== this.target.ownerDocument) {\n        parent.addEventListener('scroll', this.position);\n      }\n    });\n\n    if (pos) {\n      this.position();\n    }\n  }\n\n  disable() {\n    removeClass(this.target, this.getClass('enabled'));\n    removeClass(this.element, this.getClass('enabled'));\n    this.enabled = false;\n\n    if (typeof this.scrollParents !== 'undefined') {\n      this.scrollParents.forEach((parent) => {\n        parent.removeEventListener('scroll', this.position);\n      });\n    }\n  }\n\n  destroy() {\n    this.disable();\n\n    tethers.forEach((tether, i) => {\n      if (tether === this) {\n        tethers.splice(i, 1);\n      }\n    });\n\n    // Remove any elements we were using for convenience from the DOM\n    if (tethers.length === 0) {\n      removeUtilElements();\n    }\n  }\n\n  updateAttachClasses(elementAttach, targetAttach) {\n    elementAttach = elementAttach || this.attachment;\n    targetAttach = targetAttach || this.targetAttachment;\n    const sides = ['left', 'top', 'bottom', 'right', 'middle', 'center'];\n\n    if (typeof this._addAttachClasses !== 'undefined' && this._addAttachClasses.length) {\n      // updateAttachClasses can be called more than once in a position call, so\n      // we need to clean up after ourselves such that when the last defer gets\n      // ran it doesn't add any extra classes from previous calls.\n      this._addAttachClasses.splice(0, this._addAttachClasses.length);\n    }\n\n    if (typeof this._addAttachClasses === 'undefined') {\n      this._addAttachClasses = [];\n    }\n    const add = this._addAttachClasses;\n\n    if (elementAttach.top) {\n      add.push(`${this.getClass('element-attached')}-${elementAttach.top}`);\n    }\n    if (elementAttach.left) {\n      add.push(`${this.getClass('element-attached')}-${elementAttach.left}`);\n    }\n    if (targetAttach.top) {\n      add.push(`${this.getClass('target-attached')}-${targetAttach.top}`);\n    }\n    if (targetAttach.left) {\n      add.push(`${this.getClass('target-attached')}-${targetAttach.left}`);\n    }\n\n    const all = [];\n    sides.forEach((side) => {\n      all.push(`${this.getClass('element-attached')}-${side}`);\n      all.push(`${this.getClass('target-attached')}-${side}`);\n    });\n\n    defer(() => {\n      if (!(typeof this._addAttachClasses !== 'undefined')) {\n        return;\n      }\n\n      updateClasses(this.element, this._addAttachClasses, all);\n      if (!(this.options.addTargetClasses === false)) {\n        updateClasses(this.target, this._addAttachClasses, all);\n      }\n\n      delete this._addAttachClasses;\n    });\n  }\n\n  position(flushChanges = true) {\n    // flushChanges commits the changes immediately, leave true unless you are positioning multiple\n    // tethers (in which case call Tether.Utils.flush yourself when you're done)\n\n    if (!this.enabled) {\n      return;\n    }\n\n    this.clearCache();\n\n    // Turn 'auto' attachments into the appropriate corner or edge\n    const targetAttachment = autoToFixedAttachment(this.targetAttachment, this.attachment);\n\n    this.updateAttachClasses(this.attachment, targetAttachment);\n\n    const elementPos = this.cache('element-bounds', () => {\n      return getBounds(this.element);\n    });\n\n    let { width, height } = elementPos;\n\n    if (width === 0 && height === 0 && typeof this.lastSize !== 'undefined') {\n      // We cache the height and width to make it possible to position elements that are\n      // getting hidden.\n      ({ width, height } = this.lastSize);\n    } else {\n      this.lastSize = { width, height };\n    }\n\n    const targetPos = this.cache('target-bounds', () => {\n      return this.getTargetBounds();\n    });\n    const targetSize = targetPos;\n\n    // Get an actual px offset from the attachment\n    let offset = offsetToPx(attachmentToOffset(this.attachment), { width, height });\n    let targetOffset = offsetToPx(attachmentToOffset(targetAttachment), targetSize);\n\n    const manualOffset = offsetToPx(this.offset, { width, height });\n    const manualTargetOffset = offsetToPx(this.targetOffset, targetSize);\n\n    // Add the manually provided offset\n    offset = addOffset(offset, manualOffset);\n    targetOffset = addOffset(targetOffset, manualTargetOffset);\n\n    // It's now our goal to make (element position + offset) == (target position + target offset)\n    let left = targetPos.left + targetOffset.left - offset.left;\n    let top = targetPos.top + targetOffset.top - offset.top;\n\n    for (let i = 0; i < TetherBase.modules.length; ++i) {\n      const module = TetherBase.modules[i];\n      const ret = module.position.call(this, {\n        left,\n        top,\n        targetAttachment,\n        targetPos,\n        elementPos,\n        offset,\n        targetOffset,\n        manualOffset,\n        manualTargetOffset,\n        scrollbarSize,\n        attachment: this.attachment\n      });\n\n      if (ret === false) {\n        return false;\n      } else if (typeof ret === 'undefined' || typeof ret !== 'object') {\n        continue;\n      } else {\n        ({ top, left } = ret);\n      }\n    }\n\n    // We describe the position three different ways to give the optimizer\n    // a chance to decide the best possible way to position the element\n    // with the fewest repaints.\n    const next = {\n      // It's position relative to the page (absolute positioning when\n      // the element is a child of the body)\n      page: {\n        top,\n        left\n      },\n\n      // It's position relative to the viewport (fixed positioning)\n      viewport: {\n        top: top - pageYOffset,\n        bottom: pageYOffset - top - height + innerHeight,\n        left: left - pageXOffset,\n        right: pageXOffset - left - width + innerWidth\n      }\n    };\n\n    let doc = this.target.ownerDocument;\n    let win = doc.defaultView;\n\n    let scrollbarSize;\n    if (win.innerHeight > doc.documentElement.clientHeight) {\n      scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);\n      next.viewport.bottom -= scrollbarSize.height;\n    }\n\n    if (win.innerWidth > doc.documentElement.clientWidth) {\n      scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);\n      next.viewport.right -= scrollbarSize.width;\n    }\n\n    if (['', 'static'].indexOf(doc.body.style.position) === -1 ||\n      ['', 'static'].indexOf(doc.body.parentElement.style.position) === -1) {\n      // Absolute positioning in the body will be relative to the page, not the 'initial containing block'\n      next.page.bottom = doc.body.scrollHeight - top - height;\n      next.page.right = doc.body.scrollWidth - left - width;\n    }\n\n    if (typeof this.options.optimizations !== 'undefined' &&\n      this.options.optimizations.moveElement !== false &&\n      !(typeof this.targetModifier !== 'undefined')) {\n      const offsetParent = this.cache('target-offsetparent', () => getOffsetParent(this.target));\n      const offsetPosition = this.cache('target-offsetparent-bounds', () => getBounds(offsetParent));\n      const offsetParentStyle = getComputedStyle(offsetParent);\n      const offsetParentSize = offsetPosition;\n\n      const offsetBorder = {};\n      ['Top', 'Left', 'Bottom', 'Right'].forEach((side) => {\n        offsetBorder[side.toLowerCase()] = parseFloat(offsetParentStyle[`border${side}Width`]);\n      });\n\n      offsetPosition.right = doc.body.scrollWidth - offsetPosition.left - offsetParentSize.width + offsetBorder.right;\n      offsetPosition.bottom = doc.body.scrollHeight - offsetPosition.top - offsetParentSize.height + offsetBorder.bottom;\n\n      if (next.page.top >= (offsetPosition.top + offsetBorder.top) && next.page.bottom >= offsetPosition.bottom) {\n        if (next.page.left >= (offsetPosition.left + offsetBorder.left) && next.page.right >= offsetPosition.right) {\n          // We're within the visible part of the target's scroll parent\n          const { scrollLeft, scrollTop } = offsetParent;\n\n          // It's position relative to the target's offset parent (absolute positioning when\n          // the element is moved to be a child of the target's offset parent).\n          next.offset = {\n            top: next.page.top - offsetPosition.top + scrollTop - offsetBorder.top,\n            left: next.page.left - offsetPosition.left + scrollLeft - offsetBorder.left\n          };\n        }\n      }\n    }\n\n    // We could also travel up the DOM and try each containing context, rather than only\n    // looking at the body, but we're gonna get diminishing returns.\n\n    this.move(next);\n\n    this.history.unshift(next);\n\n    if (this.history.length > 3) {\n      this.history.pop();\n    }\n\n    if (flushChanges) {\n      flush();\n    }\n\n    return true;\n  }\n\n  // THE ISSUE\n  move(pos) {\n    if (!(typeof this.element.parentNode !== 'undefined')) {\n      return;\n    }\n\n    const same = {};\n\n    for (let type in pos) {\n      same[type] = {};\n\n      for (let key in pos[type]) {\n        let found = false;\n\n        for (let i = 0; i < this.history.length; ++i) {\n          const point = this.history[i];\n          if (typeof point[type] !== 'undefined' &&\n            !within(point[type][key], pos[type][key])) {\n            found = true;\n            break;\n          }\n\n        }\n\n        if (!found) {\n          same[type][key] = true;\n        }\n      }\n    }\n\n    let css = { top: '', left: '', right: '', bottom: '' };\n\n    const transcribe = (_same, _pos) => {\n      const hasOptimizations = typeof this.options.optimizations !== 'undefined';\n      const gpu = hasOptimizations ? this.options.optimizations.gpu : null;\n      if (gpu !== false) {\n        let yPos, xPos;\n        if (_same.top) {\n          css.top = 0;\n          yPos = _pos.top;\n        } else {\n          css.bottom = 0;\n          yPos = -_pos.bottom;\n        }\n\n        if (_same.left) {\n          css.left = 0;\n          xPos = _pos.left;\n        } else {\n          css.right = 0;\n          xPos = -_pos.right;\n        }\n\n        if (typeof window.devicePixelRatio === 'number' && devicePixelRatio % 1 === 0) {\n          xPos = Math.round(xPos * devicePixelRatio) / devicePixelRatio;\n          yPos = Math.round(yPos * devicePixelRatio) / devicePixelRatio;\n        }\n\n        css[transformKey] = `translateX(${xPos}px) translateY(${yPos}px)`;\n\n        if (transformKey !== 'msTransform') {\n          // The Z transform will keep this in the GPU (faster, and prevents artifacts),\n          // but IE9 doesn't support 3d transforms and will choke.\n          css[transformKey] += ' translateZ(0)';\n        }\n\n      } else {\n        if (_same.top) {\n          css.top = `${_pos.top}px`;\n        } else {\n          css.bottom = `${_pos.bottom}px`;\n        }\n\n        if (_same.left) {\n          css.left = `${_pos.left}px`;\n        } else {\n          css.right = `${_pos.right}px`;\n        }\n      }\n    };\n\n    const hasOptimizations = typeof this.options.optimizations !== 'undefined';\n    let allowPositionFixed = true;\n\n    if (hasOptimizations && this.options.optimizations.allowPositionFixed === false) {\n      allowPositionFixed = false;\n    }\n\n    let moved = false;\n    if ((same.page.top || same.page.bottom) && (same.page.left || same.page.right)) {\n      css.position = 'absolute';\n      transcribe(same.page, pos.page);\n\n    } else if (allowPositionFixed && (same.viewport.top || same.viewport.bottom) && (same.viewport.left || same.viewport.right)) {\n      css.position = 'fixed';\n      transcribe(same.viewport, pos.viewport);\n    } else if (typeof same.offset !== 'undefined' && same.offset.top && same.offset.left) {\n      css.position = 'absolute';\n      const offsetParent = this.cache('target-offsetparent', () => getOffsetParent(this.target));\n\n      if (getOffsetParent(this.element) !== offsetParent) {\n        defer(() => {\n          this.element.parentNode.removeChild(this.element);\n          offsetParent.appendChild(this.element);\n        });\n      }\n\n      transcribe(same.offset, pos.offset);\n      moved = true;\n\n    } else {\n      css.position = 'absolute';\n      transcribe({ top: true, left: true }, pos.page);\n    }\n\n    if (!moved) {\n      if (this.options.bodyElement) {\n        if (this.element.parentNode !== this.options.bodyElement) {\n          this.options.bodyElement.appendChild(this.element);\n        }\n      } else {\n        let offsetParentIsBody = true;\n\n        let currentNode = this.element.parentNode;\n        while (currentNode && currentNode.nodeType === 1 && currentNode.tagName !== 'BODY' && !isFullscreenElement(currentNode)) {\n          if (getComputedStyle(currentNode).position !== 'static') {\n            offsetParentIsBody = false;\n            break;\n          }\n\n          currentNode = currentNode.parentNode;\n        }\n\n        if (!offsetParentIsBody) {\n          this.element.parentNode.removeChild(this.element);\n          this.element.ownerDocument.body.appendChild(this.element);\n        }\n      }\n    }\n\n    // Any css change will trigger a repaint, so let's avoid one if nothing changed\n    const writeCSS = {};\n    let write = false;\n    for (let key in css) {\n      let val = css[key];\n      let elVal = this.element.style[key];\n\n      if (elVal !== val) {\n        write = true;\n        writeCSS[key] = val;\n      }\n    }\n\n    if (write) {\n      defer(() => {\n        extend(this.element.style, writeCSS);\n        this.trigger('repositioned');\n      });\n    }\n  }\n}\n\nTetherClass.modules = [];\n\nTetherBase.position = position;\n\nlet Tether = extend(TetherClass, TetherBase);\n\nTether.modules.push({\n  initialize() {\n    this.markers = {};\n\n    ['target', 'element'].forEach((type) => {\n      const el = document.createElement('div');\n      el.className = this.getClass(`${type}-marker`);\n\n      const dot = document.createElement('div');\n      dot.className = this.getClass('marker-dot');\n      el.appendChild(dot);\n\n      this[type].appendChild(el);\n\n      this.markers[type] = { dot, el };\n    });\n  },\n\n  position({ manualOffset, manualTargetOffset }) {\n    const offsets = {\n      element: manualOffset,\n      target: manualTargetOffset\n    };\n\n    for (let type in offsets) {\n      const offset = offsets[type];\n      for (let side in offset) {\n        let val = offset[side];\n        const notString = typeof val !== 'string';\n        if (notString ||\n          val.indexOf('%') === -1 &&\n          val.indexOf('px') === -1) {\n          val += 'px';\n        }\n\n        if (this.markers[type].dot.style[side] !== val) {\n          this.markers[type].dot.style[side] = val;\n        }\n      }\n    }\n\n    return true;\n  }\n});\n\nexport default Tether;\n"],"names":["TetherBase","Evented","on","event","handler","ctx","once","this","bindings","push","off","i","length","splice","trigger","args","context","apply","modules","zeroElement","getActualBoundingClientRect","node","boundingRect","getBoundingClientRect","rect","k","ownerDocument","document","frameElement","defaultView","frameRect","top","bottom","left","right","err","id","uniqueId","zeroPosCache","getOrigin","body","contains","createElement","setAttribute","extend","style","position","appendChild","getAttribute","defer","_scrollBarSize","out","Array","prototype","arguments","slice","forEach","obj","key","hasOwnProperty","call","deferred","fn","Utils","getScrollParents","el","getComputedStyle","parents","parent","parentNode","nodeType","overflow","overflowX","overflowY","test","indexOf","getBounds","doc","documentElement","docEl","box","origin","width","scrollWidth","height","scrollHeight","clientTop","clientLeft","clientWidth","clientHeight","getOffsetParent","offsetParent","flush","pop","getScrollBarSize","inner","outer","pointerEvents","visibility","widthContained","offsetWidth","widthScroll","removeChild","removeUtilElements","addClass","name","split","cls","trim","classList","add","removeClass","remove","updateClasses","all","BOUNDS_FORMAT","targetAttachment","options","constraints","cache","_this","element","lastSize","targetSize","getTargetBounds","targetHeight","targetWidth","allClasses","getClass","constraint","outOfBoundsClass","pinnedClass","side","addClasses","tAttachment","eAttachment","attachment","changeAttachX","changeAttachY","to","pin","bounds","tether","scrollParents","pageXOffset","pageYOffset","innerWidth","innerHeight","size","pos","win","toUpperCase","substr","parseFloat","getBoundingRect","map","p","oobClass","pinned","oob","updateAttachClasses","addTargetClasses","target","targetPos","abutted","targetPosSide","shift","shiftTop","shiftLeft","lastCall","lastDuration","pendingTimeout","tick","transformKey","transforms","undefined","tethers","now","performance","Date","Math","min","setTimeout","clearTimeout","window","addEventListener","MIRROR_LR","center","MIRROR_TB","middle","OFFSET_MAP","attachmentToOffset","addOffset","offsets","offsetToPx","offset","parseOffset","value","parseAttachment","TetherClass","bind","history","setOptions","module","initialize","classes","classPrefix","targetOffset","targetModifier","_this2","Error","jquery","querySelector","disable","enabled","enable","scrollBottom","borderTopWidth","borderBottomWidth","borderLeftWidth","fitAdj","pow","max","scrollPercentage","scrollTop","clearCache","_cache","getter","_this3","removeEventListener","_this4","destroy","_this5","elementAttach","targetAttach","_addAttachClasses","_this6","flushChanges","relativeToAttachment","autoToFixedAttachment","elementPos","_this7","manualOffset","manualTargetOffset","ret","scrollbarSize","next","page","viewport","parentElement","optimizations","moveElement","offsetPosition","offsetParentStyle","offsetParentSize","offsetBorder","toLowerCase","scrollLeft","move","unshift","a","b","diff","same","type","found","point","within","css","transcribe","_same","_pos","yPos","xPos","_this8","gpu","devicePixelRatio","round","allowPositionFixed","e","d","moved","bodyElement","offsetParentIsBody","currentNode","tagName","fullscreenElement","webkitFullscreenElement","mozFullScreenElement","msFullscreenElement","writeCSS","write","val","Tether","markers","className","_this9","dot"],"mappings":"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"}