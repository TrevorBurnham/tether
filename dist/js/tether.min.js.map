{"version":3,"file":"tether.min.js","sources":["../../src/js/utils.js","../../src/js/evented.js","../../src/js/constraint.js","../../src/js/abutment.js","../../src/js/shift.js","../../src/js/tether.js"],"sourcesContent":["let TetherBase;\nif (typeof TetherBase === 'undefined') {\n  TetherBase = { modules: [] };\n}\n\nlet zeroElement = null;\n\n// Same as native getBoundingClientRect, except it takes into account parent <frame> offsets\n// if the element lies within a nested document (<frame> or <iframe>-like).\nfunction getActualBoundingClientRect(node) {\n  let boundingRect = node.getBoundingClientRect();\n\n  // The original object returned by getBoundingClientRect is immutable, so we clone it\n  // We can't use extend because the properties are not considered part of the object by hasOwnProperty in IE9\n  let rect = {};\n  for (let k in boundingRect) {\n    rect[k] = boundingRect[k];\n  }\n\n  try {\n    if (node.ownerDocument !== document) {\n      let { frameElement } = node.ownerDocument.defaultView;\n      if (frameElement) {\n        let frameRect = getActualBoundingClientRect(frameElement);\n        rect.top += frameRect.top;\n        rect.bottom += frameRect.top;\n        rect.left += frameRect.left;\n        rect.right += frameRect.left;\n      }\n    }\n  } catch(err) {\n    // Ignore \"Access is denied\" in IE11/Edge\n  }\n\n  return rect;\n}\n\nfunction getScrollParents(el) {\n  // In firefox if the el is inside an iframe with display: none; window.getComputedStyle() will return null;\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n  const computedStyle = getComputedStyle(el) || {};\n  const { position } = computedStyle;\n  let parents = [];\n\n  if (position === 'fixed') {\n    return [el];\n  }\n\n  let parent = el;\n  while ((parent = parent.parentNode) && parent && parent.nodeType === 1) {\n    let style;\n    try {\n      style = getComputedStyle(parent);\n    } catch(err) {\n      // Intentionally blank\n    }\n\n    if (typeof style === 'undefined' || style === null) {\n      parents.push(parent);\n      return parents;\n    }\n\n    const { overflow, overflowX, overflowY } = style;\n    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n      if (position !== 'absolute' || ['relative', 'absolute', 'fixed'].indexOf(style.position) >= 0) {\n        parents.push(parent);\n      }\n    }\n  }\n\n  parents.push(el.ownerDocument.body);\n\n  // If the node is within a frame, account for the parent window scroll\n  if (el.ownerDocument !== document) {\n    parents.push(el.ownerDocument.defaultView);\n  }\n\n  return parents;\n}\n\nconst uniqueId = (() => {\n  let id = 0;\n  return () => ++id;\n})();\n\nconst zeroPosCache = {};\nconst getOrigin = () => {\n  // getBoundingClientRect is unfortunately too accurate.  It introduces a pixel or two of\n  // jitter as the user scrolls that messes with our ability to detect if two positions\n  // are equivilant or not.  We place an element at the top left of the page that will\n  // get the same jitter, so we can cancel the two out.\n  let node = zeroElement;\n  if (!node || !document.body.contains(node)) {\n    node = document.createElement('div');\n    node.setAttribute('data-tether-id', uniqueId());\n    extend(node.style, {\n      top: 0,\n      left: 0,\n      position: 'absolute'\n    });\n\n    document.body.appendChild(node);\n\n    zeroElement = node;\n  }\n\n  const id = node.getAttribute('data-tether-id');\n  if (typeof zeroPosCache[id] === 'undefined') {\n    zeroPosCache[id] = getActualBoundingClientRect(node);\n\n    // Clear the cache when this position call is done\n    defer(() => {\n      delete zeroPosCache[id];\n    });\n  }\n\n  return zeroPosCache[id];\n};\n\nfunction removeUtilElements() {\n  if (zeroElement) {\n    document.body.removeChild(zeroElement);\n  }\n  zeroElement = null;\n}\n\nfunction getBounds(el) {\n  let doc;\n  if (el === document) {\n    doc = document;\n    el = document.documentElement;\n  } else {\n    doc = el.ownerDocument;\n  }\n\n  const docEl = doc.documentElement;\n\n  const box = getActualBoundingClientRect(el);\n\n  const origin = getOrigin();\n\n  box.top -= origin.top;\n  box.left -= origin.left;\n\n  if (typeof box.width === 'undefined') {\n    box.width = document.body.scrollWidth - box.left - box.right;\n  }\n  if (typeof box.height === 'undefined') {\n    box.height = document.body.scrollHeight - box.top - box.bottom;\n  }\n\n  box.top = box.top - docEl.clientTop;\n  box.left = box.left - docEl.clientLeft;\n  box.right = doc.body.clientWidth - box.width - box.left;\n  box.bottom = doc.body.clientHeight - box.height - box.top;\n\n  return box;\n}\n\nfunction getOffsetParent(el) {\n  return el.offsetParent || document.documentElement;\n}\n\nlet _scrollBarSize = null;\n\nfunction getScrollBarSize() {\n  if (_scrollBarSize) {\n    return _scrollBarSize;\n  }\n  const inner = document.createElement('div');\n  inner.style.width = '100%';\n  inner.style.height = '200px';\n\n  const outer = document.createElement('div');\n  extend(outer.style, {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    pointerEvents: 'none',\n    visibility: 'hidden',\n    width: '200px',\n    height: '150px',\n    overflow: 'hidden'\n  });\n\n  outer.appendChild(inner);\n\n  document.body.appendChild(outer);\n\n  const widthContained = inner.offsetWidth;\n  outer.style.overflow = 'scroll';\n  let widthScroll = inner.offsetWidth;\n\n  if (widthContained === widthScroll) {\n    widthScroll = outer.clientWidth;\n  }\n\n  document.body.removeChild(outer);\n\n  const width = widthContained - widthScroll;\n\n  _scrollBarSize = { width, height: width };\n  return _scrollBarSize;\n}\n\nfunction extend(out = {}) {\n  const args = [];\n\n  Array.prototype.push.apply(args, arguments);\n\n  args.slice(1).forEach((obj) => {\n    if (obj) {\n      for (let key in obj) {\n        if ({}.hasOwnProperty.call(obj, key)) {\n          out[key] = obj[key];\n        }\n      }\n    }\n  });\n\n  return out;\n}\n\nfunction removeClass(el, name) {\n  if (typeof el.classList !== 'undefined') {\n    name.split(' ').forEach((cls) => {\n      if (cls.trim()) {\n        el.classList.remove(cls);\n      }\n    });\n  } else {\n    const regex = new RegExp(`(^| )${name.split(' ').join('|')}( |$)`, 'gi');\n    const className = getClassName(el).replace(regex, ' ');\n    setClassName(el, className);\n  }\n}\n\nfunction addClass(el, name) {\n  if (typeof el.classList !== 'undefined') {\n    name.split(' ').forEach((cls) => {\n      if (cls.trim()) {\n        el.classList.add(cls);\n      }\n    });\n  } else {\n    removeClass(el, name);\n    const cls = `${getClassName(el)} ${name}`;\n    setClassName(el, cls);\n  }\n}\n\nfunction hasClass(el, name) {\n  if (typeof el.classList !== 'undefined') {\n    return el.classList.contains(name);\n  }\n  const className = getClassName(el);\n  return new RegExp(`(^| )${name}( |$)`, 'gi').test(className);\n}\n\nfunction getClassName(el) {\n  // Can't use just SVGAnimatedString here since nodes within a Frame in IE have\n  // completely separately SVGAnimatedString base classes\n  if (el.className instanceof el.ownerDocument.defaultView.SVGAnimatedString) {\n    return el.className.baseVal;\n  }\n  return el.className;\n}\n\nfunction setClassName(el, className) {\n  el.setAttribute('class', className);\n}\n\nfunction updateClasses(el, add, all) {\n  // Of the set of 'all' classes, we need the 'add' classes, and only the\n  // 'add' classes to be set.\n  all.forEach((cls) => {\n    if (add.indexOf(cls) === -1 && hasClass(el, cls)) {\n      removeClass(el, cls);\n    }\n  });\n\n  add.forEach((cls) => {\n    if (!hasClass(el, cls)) {\n      addClass(el, cls);\n    }\n  });\n}\n\nconst deferred = [];\n\nconst defer = (fn) => {\n  deferred.push(fn);\n};\n\nconst flush = () => {\n  let fn;\n  // eslint-disable-next-line\n  while (fn = deferred.pop()) {\n    fn();\n  }\n};\n\nTetherBase.Utils = {\n  getActualBoundingClientRect,\n  getScrollParents,\n  getBounds,\n  getOffsetParent,\n  extend,\n  addClass,\n  removeClass,\n  hasClass,\n  updateClasses,\n  defer,\n  flush,\n  uniqueId,\n  getScrollBarSize,\n  removeUtilElements\n};\n\nexport default TetherBase;\n","export class Evented {\n  on(event, handler, ctx, once = false) {\n    if (typeof this.bindings === 'undefined') {\n      this.bindings = {};\n    }\n    if (typeof this.bindings[event] === 'undefined') {\n      this.bindings[event] = [];\n    }\n    this.bindings[event].push({ handler, ctx, once });\n\n    return this;\n  }\n\n  once(event, handler, ctx) {\n    return this.on(event, handler, ctx, true);\n  }\n\n  off(event, handler) {\n    if (typeof this.bindings === 'undefined' ||\n      typeof this.bindings[event] === 'undefined') {\n      return this;\n    }\n\n    if (typeof handler === 'undefined') {\n      delete this.bindings[event];\n    } else {\n      let i = 0;\n      while (i < this.bindings[event].length) {\n        if (this.bindings[event][i].handler === handler) {\n          this.bindings[event].splice(i, 1);\n        } else {\n          ++i;\n        }\n      }\n    }\n\n    return this;\n  }\n\n  trigger(event, ...args) {\n    if (typeof this.bindings !== 'undefined' && this.bindings[event]) {\n      let i = 0;\n      while (i < this.bindings[event].length) {\n        const { handler, ctx, once } = this.bindings[event][i];\n\n        let context = ctx;\n        if (typeof context === 'undefined') {\n          context = this;\n        }\n\n        handler.apply(context, args);\n\n        if (once) {\n          this.bindings[event].splice(i, 1);\n        } else {\n          ++i;\n        }\n      }\n    }\n\n    return this;\n  }\n}\n","import TetherBase from './utils';\n\nconst {\n  getBounds,\n  extend,\n  updateClasses,\n  defer\n} = TetherBase.Utils;\n\nconst BOUNDS_FORMAT = ['left', 'top', 'right', 'bottom'];\n\nfunction getBoundingRect(tether, to) {\n  if (to === 'scrollParent') {\n    to = tether.scrollParents[0];\n  } else if (to === 'window') {\n    to = [pageXOffset, pageYOffset, innerWidth + pageXOffset, innerHeight + pageYOffset];\n  }\n\n  if (to === document) {\n    to = to.documentElement;\n  }\n\n  if (typeof to.nodeType !== 'undefined') {\n    const node = to;\n    const size = getBounds(to);\n    const pos = size;\n    const style = getComputedStyle(to);\n\n    to = [pos.left, pos.top, size.width + pos.left, size.height + pos.top];\n\n    // Account any parent Frames scroll offset\n    if (node.ownerDocument !== document) {\n      let win = node.ownerDocument.defaultView;\n      to[0] += win.pageXOffset;\n      to[1] += win.pageYOffset;\n      to[2] += win.pageXOffset;\n      to[3] += win.pageYOffset;\n    }\n\n    BOUNDS_FORMAT.forEach((side, i) => {\n      side = side[0].toUpperCase() + side.substr(1);\n      if (side === 'Top' || side === 'Left') {\n        to[i] += parseFloat(style[`border${side}Width`]);\n      } else {\n        to[i] -= parseFloat(style[`border${side}Width`]);\n      }\n    });\n  }\n\n  return to;\n}\n\nTetherBase.modules.push({\n  position({ top, left, targetAttachment }) {\n    if (!this.options.constraints) {\n      return true;\n    }\n\n    let { height, width } = this.cache('element-bounds', () => {\n      return getBounds(this.element);\n    });\n\n    if (width === 0 && height === 0 && typeof this.lastSize !== 'undefined') {\n      // Handle the item getting hidden as a result of our positioning without glitching\n      // the classes in and out\n      ({ width, height } = this.lastSize);\n    }\n\n    const targetSize = this.cache('target-bounds', () => {\n      return this.getTargetBounds();\n    });\n\n    const { height: targetHeight, width: targetWidth } = targetSize;\n\n    const allClasses = [this.getClass('pinned'), this.getClass('out-of-bounds')];\n\n    this.options.constraints.forEach((constraint) => {\n      const { outOfBoundsClass, pinnedClass } = constraint;\n      if (outOfBoundsClass) {\n        allClasses.push(outOfBoundsClass);\n      }\n      if (pinnedClass) {\n        allClasses.push(pinnedClass);\n      }\n    });\n\n    allClasses.forEach((cls) => {\n      ['left', 'top', 'right', 'bottom'].forEach((side) => {\n        allClasses.push(`${cls}-${side}`);\n      });\n    });\n\n    const addClasses = [];\n\n    const tAttachment = extend({}, targetAttachment);\n    const eAttachment = extend({}, this.attachment);\n\n    this.options.constraints.forEach((constraint) => {\n      let { to, attachment, pin } = constraint;\n\n      if (typeof attachment === 'undefined') {\n        attachment = '';\n      }\n\n      let changeAttachX, changeAttachY;\n      if (attachment.indexOf(' ') >= 0) {\n        [changeAttachY, changeAttachX] = attachment.split(' ');\n      } else {\n        changeAttachX = changeAttachY = attachment;\n      }\n\n      const bounds = getBoundingRect(this, to);\n\n      if (changeAttachY === 'target' || changeAttachY === 'both') {\n        if (top < bounds[1] && tAttachment.top === 'top') {\n          top += targetHeight;\n          tAttachment.top = 'bottom';\n        }\n\n        if (top + height > bounds[3] && tAttachment.top === 'bottom') {\n          top -= targetHeight;\n          tAttachment.top = 'top';\n        }\n      }\n\n      if (changeAttachY === 'together') {\n        if (tAttachment.top === 'top') {\n          if (eAttachment.top === 'bottom' && top < bounds[1]) {\n            top += targetHeight;\n            tAttachment.top = 'bottom';\n\n            top += height;\n            eAttachment.top = 'top';\n\n          } else if (eAttachment.top === 'top' && top + height > bounds[3] && top - (height - targetHeight) >= bounds[1]) {\n            top -= height - targetHeight;\n            tAttachment.top = 'bottom';\n\n            eAttachment.top = 'bottom';\n          }\n        }\n\n        if (tAttachment.top === 'bottom') {\n          if (eAttachment.top === 'top' && top + height > bounds[3]) {\n            top -= targetHeight;\n            tAttachment.top = 'top';\n\n            top -= height;\n            eAttachment.top = 'bottom';\n\n          } else if (eAttachment.top === 'bottom' && top < bounds[1] && top + (height * 2 - targetHeight) <= bounds[3]) {\n            top += height - targetHeight;\n            tAttachment.top = 'top';\n\n            eAttachment.top = 'top';\n\n          }\n        }\n\n        if (tAttachment.top === 'middle') {\n          if (top + height > bounds[3] && eAttachment.top === 'top') {\n            top -= height;\n            eAttachment.top = 'bottom';\n\n          } else if (top < bounds[1] && eAttachment.top === 'bottom') {\n            top += height;\n            eAttachment.top = 'top';\n          }\n        }\n      }\n\n      if (changeAttachX === 'target' || changeAttachX === 'both') {\n        if (left < bounds[0] && tAttachment.left === 'left') {\n          left += targetWidth;\n          tAttachment.left = 'right';\n        }\n\n        if (left + width > bounds[2] && tAttachment.left === 'right') {\n          left -= targetWidth;\n          tAttachment.left = 'left';\n        }\n      }\n\n      if (changeAttachX === 'together') {\n        if (left < bounds[0] && tAttachment.left === 'left') {\n          if (eAttachment.left === 'right') {\n            left += targetWidth;\n            tAttachment.left = 'right';\n\n            left += width;\n            eAttachment.left = 'left';\n\n          } else if (eAttachment.left === 'left') {\n            left += targetWidth;\n            tAttachment.left = 'right';\n\n            left -= width;\n            eAttachment.left = 'right';\n          }\n\n        } else if (left + width > bounds[2] && tAttachment.left === 'right') {\n          if (eAttachment.left === 'left') {\n            left -= targetWidth;\n            tAttachment.left = 'left';\n\n            left -= width;\n            eAttachment.left = 'right';\n\n          } else if (eAttachment.left === 'right') {\n            left -= targetWidth;\n            tAttachment.left = 'left';\n\n            left += width;\n            eAttachment.left = 'left';\n          }\n\n        } else if (tAttachment.left === 'center') {\n          if (left + width > bounds[2] && eAttachment.left === 'left') {\n            left -= width;\n            eAttachment.left = 'right';\n\n          } else if (left < bounds[0] && eAttachment.left === 'right') {\n            left += width;\n            eAttachment.left = 'left';\n          }\n        }\n      }\n\n      if (changeAttachY === 'element' || changeAttachY === 'both') {\n        if (top < bounds[1] && eAttachment.top === 'bottom') {\n          top += height;\n          eAttachment.top = 'top';\n        }\n\n        if (top + height > bounds[3] && eAttachment.top === 'top') {\n          top -= height;\n          eAttachment.top = 'bottom';\n        }\n      }\n\n      if (changeAttachX === 'element' || changeAttachX === 'both') {\n        if (left < bounds[0]) {\n          if (eAttachment.left === 'right') {\n            left += width;\n            eAttachment.left = 'left';\n          } else if (eAttachment.left === 'center') {\n            left += (width / 2);\n            eAttachment.left = 'left';\n          }\n        }\n\n        if (left + width > bounds[2]) {\n          if (eAttachment.left === 'left') {\n            left -= width;\n            eAttachment.left = 'right';\n          } else if (eAttachment.left === 'center') {\n            left -= (width / 2);\n            eAttachment.left = 'right';\n          }\n        }\n      }\n\n      if (typeof pin === 'string') {\n        pin = pin.split(',').map((p) => p.trim());\n      } else if (pin === true) {\n        pin = ['top', 'left', 'right', 'bottom'];\n      }\n\n      pin = pin || [];\n\n      const pinned = [];\n      const oob = [];\n\n      if (top < bounds[1]) {\n        if (pin.indexOf('top') >= 0) {\n          top = bounds[1];\n          pinned.push('top');\n        } else {\n          oob.push('top');\n        }\n      }\n\n      if (top + height > bounds[3]) {\n        if (pin.indexOf('bottom') >= 0) {\n          top = bounds[3] - height;\n          pinned.push('bottom');\n        } else {\n          oob.push('bottom');\n        }\n      }\n\n      if (left < bounds[0]) {\n        if (pin.indexOf('left') >= 0) {\n          left = bounds[0];\n          pinned.push('left');\n        } else {\n          oob.push('left');\n        }\n      }\n\n      if (left + width > bounds[2]) {\n        if (pin.indexOf('right') >= 0) {\n          left = bounds[2] - width;\n          pinned.push('right');\n        } else {\n          oob.push('right');\n        }\n      }\n\n      if (pinned.length) {\n        let pinnedClass;\n        if (typeof this.options.pinnedClass !== 'undefined') {\n          pinnedClass = this.options.pinnedClass;\n        } else {\n          pinnedClass = this.getClass('pinned');\n        }\n\n        addClasses.push(pinnedClass);\n        pinned.forEach((side) => {\n          addClasses.push(`${pinnedClass}-${side}`);\n        });\n      }\n\n      if (oob.length) {\n        let oobClass;\n        if (typeof this.options.outOfBoundsClass !== 'undefined') {\n          oobClass = this.options.outOfBoundsClass;\n        } else {\n          oobClass = this.getClass('out-of-bounds');\n        }\n\n        addClasses.push(oobClass);\n        oob.forEach((side) => {\n          addClasses.push(`${oobClass}-${side}`);\n        });\n      }\n\n      if (pinned.indexOf('left') >= 0 || pinned.indexOf('right') >= 0) {\n        eAttachment.left = tAttachment.left = false;\n      }\n      if (pinned.indexOf('top') >= 0 || pinned.indexOf('bottom') >= 0) {\n        eAttachment.top = tAttachment.top = false;\n      }\n\n      if (tAttachment.top !== targetAttachment.top ||\n        tAttachment.left !== targetAttachment.left ||\n        eAttachment.top !== this.attachment.top ||\n        eAttachment.left !== this.attachment.left) {\n        this.updateAttachClasses(eAttachment, tAttachment);\n        this.trigger('update', {\n          attachment: eAttachment,\n          targetAttachment: tAttachment\n        });\n      }\n    });\n\n    defer(() => {\n      if (!(this.options.addTargetClasses === false)) {\n        updateClasses(this.target, addClasses, allClasses);\n      }\n      updateClasses(this.element, addClasses, allClasses);\n    });\n\n    return { top, left };\n  }\n});\n","import TetherBase from './utils';\n\nconst { getBounds, updateClasses, defer } = TetherBase.Utils;\n\nTetherBase.modules.push({\n  position({ top, left }) {\n    const { height, width } = this.cache('element-bounds', () => {\n      return getBounds(this.element);\n    });\n\n    const targetPos = this.getTargetBounds();\n\n    const bottom = top + height;\n    const right = left + width;\n\n    const abutted = [];\n    if (top <= targetPos.bottom && bottom >= targetPos.top) {\n      ['left', 'right'].forEach((side) => {\n        const targetPosSide = targetPos[side];\n        if (targetPosSide === left || targetPosSide === right) {\n          abutted.push(side);\n        }\n      });\n    }\n\n    if (left <= targetPos.right && right >= targetPos.left) {\n      ['top', 'bottom'].forEach((side) => {\n        const targetPosSide = targetPos[side];\n        if (targetPosSide === top || targetPosSide === bottom) {\n          abutted.push(side);\n        }\n      });\n    }\n\n    const allClasses = [];\n    const addClasses = [];\n\n    const sides = ['left', 'top', 'right', 'bottom'];\n    allClasses.push(this.getClass('abutted'));\n    sides.forEach((side) => {\n      allClasses.push(`${this.getClass('abutted')}-${side}`);\n    });\n\n    if (abutted.length) {\n      addClasses.push(this.getClass('abutted'));\n    }\n\n    abutted.forEach((side) => {\n      addClasses.push(`${this.getClass('abutted')}-${side}`);\n    });\n\n    defer(() => {\n      if (!(this.options.addTargetClasses === false)) {\n        updateClasses(this.target, addClasses, allClasses);\n      }\n      updateClasses(this.element, addClasses, allClasses);\n    });\n\n    return true;\n  }\n});\n","import TetherBase from './utils';\n\nTetherBase.modules.push({\n  position({ top, left }) {\n    if (!this.options.shift) {\n      return;\n    }\n\n    let { shift } = this.options;\n    if (typeof shift === 'function') {\n      shift = shift.call(this, { top, left });\n    }\n\n    let shiftTop, shiftLeft;\n    if (typeof shift === 'string') {\n      shift = shift.split(' ');\n      shift[1] = shift[1] || shift[0];\n\n      ([shiftTop, shiftLeft] = shift);\n\n      shiftTop = parseFloat(shiftTop, 10);\n      shiftLeft = parseFloat(shiftLeft, 10);\n    } else {\n      ([shiftTop, shiftLeft] = [shift.top, shift.left]);\n    }\n\n    top += shiftTop;\n    left += shiftLeft;\n\n    return { top, left };\n  }\n});\n","/* globals TetherBase */\n\nimport '../css/tether.scss';\nimport '../css/tether-theme-arrows.scss';\nimport '../css/tether-theme-arrows-dark.scss';\nimport '../css/tether-theme-basic.scss';\nimport { Evented } from './evented';\nimport TetherBase from './utils';\nimport './constraint';\nimport './abutment';\nimport './shift';\n\nconst {\n  getScrollParents,\n  getBounds,\n  getOffsetParent,\n  extend,\n  addClass,\n  removeClass,\n  updateClasses,\n  defer,\n  flush,\n  getScrollBarSize,\n  removeUtilElements\n} = TetherBase.Utils;\n\nfunction isFullscreenElement(e) {\n  let d = e.ownerDocument;\n  let fe = d.fullscreenElement || d.webkitFullscreenElement || d.mozFullScreenElement || d.msFullscreenElement;\n  return fe === e;\n}\n\nfunction within(a, b, diff = 1) {\n  return (a + diff >= b && b >= a - diff);\n}\n\nconst transformKey = (() => {\n  if (typeof document === 'undefined') {\n    return '';\n  }\n  const el = document.createElement('div');\n\n  const transforms = ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform'];\n  for (let i = 0; i < transforms.length; ++i) {\n    const key = transforms[i];\n    if (el.style[key] !== undefined) {\n      return key;\n    }\n  }\n})();\n\nconst tethers = [];\n\nconst position = () => {\n  tethers.forEach((tether) => {\n    tether.position(false);\n  });\n  flush();\n};\n\nfunction now() {\n  if (typeof performance === 'object' && typeof performance.now === 'function') {\n    return performance.now();\n  }\n  return +new Date;\n}\n\n(() => {\n  let lastCall = null;\n  let lastDuration = null;\n  let pendingTimeout = null;\n\n  const tick = () => {\n    if (typeof lastDuration !== 'undefined' && lastDuration > 16) {\n      // We voluntarily throttle ourselves if we can't manage 60fps\n      lastDuration = Math.min(lastDuration - 16, 250);\n\n      // Just in case this is the last event, remember to position just once more\n      pendingTimeout = setTimeout(tick, 250);\n      return;\n    }\n\n    if (typeof lastCall !== 'undefined' && (now() - lastCall) < 10) {\n      // Some browsers call events a little too frequently, refuse to run more than is reasonable\n      return;\n    }\n\n    if (pendingTimeout != null) {\n      clearTimeout(pendingTimeout);\n      pendingTimeout = null;\n    }\n\n    lastCall = now();\n    position();\n    lastDuration = now() - lastCall;\n  };\n\n  if (typeof window !== 'undefined' && typeof window.addEventListener !== 'undefined') {\n    ['resize', 'scroll', 'touchmove'].forEach((event) => {\n      window.addEventListener(event, tick);\n    });\n  }\n})();\n\nconst MIRROR_LR = {\n  center: 'center',\n  left: 'right',\n  right: 'left'\n};\n\nconst MIRROR_TB = {\n  middle: 'middle',\n  top: 'bottom',\n  bottom: 'top'\n};\n\nconst OFFSET_MAP = {\n  top: 0,\n  left: 0,\n  middle: '50%',\n  center: '50%',\n  bottom: '100%',\n  right: '100%'\n};\n\nconst autoToFixedAttachment = (attachment, relativeToAttachment) => {\n  let { left, top } = attachment;\n\n  if (left === 'auto') {\n    left = MIRROR_LR[relativeToAttachment.left];\n  }\n\n  if (top === 'auto') {\n    top = MIRROR_TB[relativeToAttachment.top];\n  }\n\n  return { left, top };\n};\n\nconst attachmentToOffset = (attachment) => {\n  let { left, top } = attachment;\n\n  if (typeof OFFSET_MAP[attachment.left] !== 'undefined') {\n    left = OFFSET_MAP[attachment.left];\n  }\n\n  if (typeof OFFSET_MAP[attachment.top] !== 'undefined') {\n    top = OFFSET_MAP[attachment.top];\n  }\n\n  return { left, top };\n};\n\nfunction addOffset(...offsets) {\n  const out = { top: 0, left: 0 };\n\n  offsets.forEach(({ top, left }) => {\n    if (typeof top === 'string') {\n      top = parseFloat(top, 10);\n    }\n    if (typeof left === 'string') {\n      left = parseFloat(left, 10);\n    }\n\n    out.top += top;\n    out.left += left;\n  });\n\n  return out;\n}\n\nfunction offsetToPx(offset, size) {\n  if (typeof offset.left === 'string' && offset.left.indexOf('%') !== -1) {\n    offset.left = parseFloat(offset.left, 10) / 100 * size.width;\n  }\n  if (typeof offset.top === 'string' && offset.top.indexOf('%') !== -1) {\n    offset.top = parseFloat(offset.top, 10) / 100 * size.height;\n  }\n\n  return offset;\n}\n\nconst parseOffset = (value) => {\n  const [top, left] = value.split(' ');\n  return { top, left };\n};\nconst parseAttachment = parseOffset;\n\nclass TetherClass extends Evented {\n\n  constructor(options) {\n    super();\n    this.position = this.position.bind(this);\n\n    tethers.push(this);\n\n    this.history = [];\n\n    this.setOptions(options, false);\n\n    TetherBase.modules.forEach((module) => {\n      if (typeof module.initialize !== 'undefined') {\n        module.initialize.call(this);\n      }\n    });\n\n    this.position();\n  }\n\n  getClass(key = '') {\n    const { classes } = this.options;\n    if (typeof classes !== 'undefined' && classes[key]) {\n      return this.options.classes[key];\n    } else if (this.options.classPrefix) {\n      return `${this.options.classPrefix}-${key}`;\n    } else {\n      return key;\n    }\n  }\n\n  setOptions(options, pos = true) {\n    const defaults = {\n      offset: '0 0',\n      targetOffset: '0 0',\n      targetAttachment: 'auto auto',\n      classPrefix: 'tether'\n    };\n\n    this.options = extend(defaults, options);\n\n    let { element, target, targetModifier } = this.options;\n    this.element = element;\n    this.target = target;\n    this.targetModifier = targetModifier;\n\n    if (this.target === 'viewport') {\n      this.target = document.body;\n      this.targetModifier = 'visible';\n    } else if (this.target === 'scroll-handle') {\n      this.target = document.body;\n      this.targetModifier = 'scroll-handle';\n    }\n\n    ['element', 'target'].forEach((key) => {\n      if (typeof this[key] === 'undefined') {\n        throw new Error('Tether Error: Both element and target must be defined');\n      }\n\n      if (typeof this[key].jquery !== 'undefined') {\n        this[key] = this[key][0];\n      } else if (typeof this[key] === 'string') {\n        this[key] = document.querySelector(this[key]);\n      }\n    });\n\n    addClass(this.element, this.getClass('element'));\n    if (!(this.options.addTargetClasses === false)) {\n      addClass(this.target, this.getClass('target'));\n    }\n\n    if (!this.options.attachment) {\n      throw new Error('Tether Error: You must provide an attachment');\n    }\n\n    this.targetAttachment = parseAttachment(this.options.targetAttachment);\n    this.attachment = parseAttachment(this.options.attachment);\n    this.offset = parseOffset(this.options.offset);\n    this.targetOffset = parseOffset(this.options.targetOffset);\n\n    if (typeof this.scrollParents !== 'undefined') {\n      this.disable();\n    }\n\n    if (this.targetModifier === 'scroll-handle') {\n      this.scrollParents = [this.target];\n    } else {\n      this.scrollParents = getScrollParents(this.target);\n    }\n\n    if (!(this.options.enabled === false)) {\n      this.enable(pos);\n    }\n  }\n\n  getTargetBounds() {\n    if (typeof this.targetModifier !== 'undefined') {\n      if (this.targetModifier === 'visible') {\n        if (this.target === document.body) {\n          return { top: pageYOffset, left: pageXOffset, height: innerHeight, width: innerWidth };\n        } else {\n          const bounds = getBounds(this.target);\n\n          const out = {\n            height: bounds.height,\n            width: bounds.width,\n            top: bounds.top,\n            left: bounds.left\n          };\n\n          out.height = Math.min(out.height, bounds.height - (pageYOffset - bounds.top));\n          out.height = Math.min(out.height, bounds.height - ((bounds.top + bounds.height) - (pageYOffset + innerHeight)));\n          out.height = Math.min(innerHeight, out.height);\n          out.height -= 2;\n\n          out.width = Math.min(out.width, bounds.width - (pageXOffset - bounds.left));\n          out.width = Math.min(out.width, bounds.width - ((bounds.left + bounds.width) - (pageXOffset + innerWidth)));\n          out.width = Math.min(innerWidth, out.width);\n          out.width -= 2;\n\n          if (out.top < pageYOffset) {\n            out.top = pageYOffset;\n          }\n          if (out.left < pageXOffset) {\n            out.left = pageXOffset;\n          }\n\n          return out;\n        }\n      } else if (this.targetModifier === 'scroll-handle') {\n        let bounds;\n        let { target } = this;\n        if (target === document.body) {\n          target = document.documentElement;\n\n          bounds = {\n            left: pageXOffset,\n            top: pageYOffset,\n            height: innerHeight,\n            width: innerWidth\n          };\n        } else {\n          bounds = getBounds(target);\n        }\n\n        const style = getComputedStyle(target);\n\n        const hasBottomScroll = (\n          target.scrollWidth > target.clientWidth ||\n          [style.overflow, style.overflowX].indexOf('scroll') >= 0 ||\n          this.target !== document.body\n        );\n\n        let scrollBottom = 0;\n        if (hasBottomScroll) {\n          scrollBottom = 15;\n        }\n\n        const height = bounds.height - parseFloat(style.borderTopWidth) - parseFloat(style.borderBottomWidth) - scrollBottom;\n\n        const out = {\n          width: 15,\n          height: height * 0.975 * (height / target.scrollHeight),\n          left: bounds.left + bounds.width - parseFloat(style.borderLeftWidth) - 15\n        };\n\n        let fitAdj = 0;\n        if (height < 408 && this.target === document.body) {\n          fitAdj = -0.00011 * Math.pow(height, 2) - 0.00727 * height + 22.58;\n        }\n\n        if (this.target !== document.body) {\n          out.height = Math.max(out.height, 24);\n        }\n\n        const scrollPercentage = this.target.scrollTop / (target.scrollHeight - height);\n        out.top = scrollPercentage * (height - out.height - fitAdj) + bounds.top + parseFloat(style.borderTopWidth);\n\n        if (this.target === document.body) {\n          out.height = Math.max(out.height, 24);\n        }\n\n        return out;\n      }\n    } else {\n      return getBounds(this.target);\n    }\n  }\n\n  clearCache() {\n    this._cache = {};\n  }\n\n  cache(k, getter) {\n    // More than one module will often need the same DOM info, so\n    // we keep a cache which is cleared on each position call\n    if (typeof this._cache === 'undefined') {\n      this._cache = {};\n    }\n\n    if (typeof this._cache[k] === 'undefined') {\n      this._cache[k] = getter.call(this);\n    }\n\n    return this._cache[k];\n  }\n\n  enable(pos = true) {\n    if (!(this.options.addTargetClasses === false)) {\n      addClass(this.target, this.getClass('enabled'));\n    }\n    addClass(this.element, this.getClass('enabled'));\n    this.enabled = true;\n\n    this.scrollParents.forEach((parent) => {\n      if (parent !== this.target.ownerDocument) {\n        parent.addEventListener('scroll', this.position);\n      }\n    });\n\n    if (pos) {\n      this.position();\n    }\n  }\n\n  disable() {\n    removeClass(this.target, this.getClass('enabled'));\n    removeClass(this.element, this.getClass('enabled'));\n    this.enabled = false;\n\n    if (typeof this.scrollParents !== 'undefined') {\n      this.scrollParents.forEach((parent) => {\n        parent.removeEventListener('scroll', this.position);\n      });\n    }\n  }\n\n  destroy() {\n    this.disable();\n\n    tethers.forEach((tether, i) => {\n      if (tether === this) {\n        tethers.splice(i, 1);\n      }\n    });\n\n    // Remove any elements we were using for convenience from the DOM\n    if (tethers.length === 0) {\n      removeUtilElements();\n    }\n  }\n\n  updateAttachClasses(elementAttach, targetAttach) {\n    elementAttach = elementAttach || this.attachment;\n    targetAttach = targetAttach || this.targetAttachment;\n    const sides = ['left', 'top', 'bottom', 'right', 'middle', 'center'];\n\n    if (typeof this._addAttachClasses !== 'undefined' && this._addAttachClasses.length) {\n      // updateAttachClasses can be called more than once in a position call, so\n      // we need to clean up after ourselves such that when the last defer gets\n      // ran it doesn't add any extra classes from previous calls.\n      this._addAttachClasses.splice(0, this._addAttachClasses.length);\n    }\n\n    if (typeof this._addAttachClasses === 'undefined') {\n      this._addAttachClasses = [];\n    }\n    const add = this._addAttachClasses;\n\n    if (elementAttach.top) {\n      add.push(`${this.getClass('element-attached')}-${elementAttach.top}`);\n    }\n    if (elementAttach.left) {\n      add.push(`${this.getClass('element-attached')}-${elementAttach.left}`);\n    }\n    if (targetAttach.top) {\n      add.push(`${this.getClass('target-attached')}-${targetAttach.top}`);\n    }\n    if (targetAttach.left) {\n      add.push(`${this.getClass('target-attached')}-${targetAttach.left}`);\n    }\n\n    const all = [];\n    sides.forEach((side) => {\n      all.push(`${this.getClass('element-attached')}-${side}`);\n      all.push(`${this.getClass('target-attached')}-${side}`);\n    });\n\n    defer(() => {\n      if (!(typeof this._addAttachClasses !== 'undefined')) {\n        return;\n      }\n\n      updateClasses(this.element, this._addAttachClasses, all);\n      if (!(this.options.addTargetClasses === false)) {\n        updateClasses(this.target, this._addAttachClasses, all);\n      }\n\n      delete this._addAttachClasses;\n    });\n  }\n\n  position(flushChanges = true) {\n    // flushChanges commits the changes immediately, leave true unless you are positioning multiple\n    // tethers (in which case call Tether.Utils.flush yourself when you're done)\n\n    if (!this.enabled) {\n      return;\n    }\n\n    this.clearCache();\n\n    // Turn 'auto' attachments into the appropriate corner or edge\n    const targetAttachment = autoToFixedAttachment(this.targetAttachment, this.attachment);\n\n    this.updateAttachClasses(this.attachment, targetAttachment);\n\n    const elementPos = this.cache('element-bounds', () => {\n      return getBounds(this.element);\n    });\n\n    let { width, height } = elementPos;\n\n    if (width === 0 && height === 0 && typeof this.lastSize !== 'undefined') {\n      // We cache the height and width to make it possible to position elements that are\n      // getting hidden.\n      ({ width, height } = this.lastSize);\n    } else {\n      this.lastSize = { width, height };\n    }\n\n    const targetPos = this.cache('target-bounds', () => {\n      return this.getTargetBounds();\n    });\n    const targetSize = targetPos;\n\n    // Get an actual px offset from the attachment\n    let offset = offsetToPx(attachmentToOffset(this.attachment), { width, height });\n    let targetOffset = offsetToPx(attachmentToOffset(targetAttachment), targetSize);\n\n    const manualOffset = offsetToPx(this.offset, { width, height });\n    const manualTargetOffset = offsetToPx(this.targetOffset, targetSize);\n\n    // Add the manually provided offset\n    offset = addOffset(offset, manualOffset);\n    targetOffset = addOffset(targetOffset, manualTargetOffset);\n\n    // It's now our goal to make (element position + offset) == (target position + target offset)\n    let left = targetPos.left + targetOffset.left - offset.left;\n    let top = targetPos.top + targetOffset.top - offset.top;\n\n    for (let i = 0; i < TetherBase.modules.length; ++i) {\n      const module = TetherBase.modules[i];\n      const ret = module.position.call(this, {\n        left,\n        top,\n        targetAttachment,\n        targetPos,\n        elementPos,\n        offset,\n        targetOffset,\n        manualOffset,\n        manualTargetOffset,\n        scrollbarSize,\n        attachment: this.attachment\n      });\n\n      if (ret === false) {\n        return false;\n      } else if (typeof ret === 'undefined' || typeof ret !== 'object') {\n        continue;\n      } else {\n        ({ top, left } = ret);\n      }\n    }\n\n    // We describe the position three different ways to give the optimizer\n    // a chance to decide the best possible way to position the element\n    // with the fewest repaints.\n    const next = {\n      // It's position relative to the page (absolute positioning when\n      // the element is a child of the body)\n      page: {\n        top,\n        left\n      },\n\n      // It's position relative to the viewport (fixed positioning)\n      viewport: {\n        top: top - pageYOffset,\n        bottom: pageYOffset - top - height + innerHeight,\n        left: left - pageXOffset,\n        right: pageXOffset - left - width + innerWidth\n      }\n    };\n\n    let doc = this.target.ownerDocument;\n    let win = doc.defaultView;\n\n    let scrollbarSize;\n    if (win.innerHeight > doc.documentElement.clientHeight) {\n      scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);\n      next.viewport.bottom -= scrollbarSize.height;\n    }\n\n    if (win.innerWidth > doc.documentElement.clientWidth) {\n      scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);\n      next.viewport.right -= scrollbarSize.width;\n    }\n\n    if (['', 'static'].indexOf(doc.body.style.position) === -1 ||\n      ['', 'static'].indexOf(doc.body.parentElement.style.position) === -1) {\n      // Absolute positioning in the body will be relative to the page, not the 'initial containing block'\n      next.page.bottom = doc.body.scrollHeight - top - height;\n      next.page.right = doc.body.scrollWidth - left - width;\n    }\n\n    if (typeof this.options.optimizations !== 'undefined' &&\n      this.options.optimizations.moveElement !== false &&\n      !(typeof this.targetModifier !== 'undefined')) {\n      const offsetParent = this.cache('target-offsetparent', () => getOffsetParent(this.target));\n      const offsetPosition = this.cache('target-offsetparent-bounds', () => getBounds(offsetParent));\n      const offsetParentStyle = getComputedStyle(offsetParent);\n      const offsetParentSize = offsetPosition;\n\n      const offsetBorder = {};\n      ['Top', 'Left', 'Bottom', 'Right'].forEach((side) => {\n        offsetBorder[side.toLowerCase()] = parseFloat(offsetParentStyle[`border${side}Width`]);\n      });\n\n      offsetPosition.right = doc.body.scrollWidth - offsetPosition.left - offsetParentSize.width + offsetBorder.right;\n      offsetPosition.bottom = doc.body.scrollHeight - offsetPosition.top - offsetParentSize.height + offsetBorder.bottom;\n\n      if (next.page.top >= (offsetPosition.top + offsetBorder.top) && next.page.bottom >= offsetPosition.bottom) {\n        if (next.page.left >= (offsetPosition.left + offsetBorder.left) && next.page.right >= offsetPosition.right) {\n          // We're within the visible part of the target's scroll parent\n          const { scrollLeft, scrollTop } = offsetParent;\n\n          // It's position relative to the target's offset parent (absolute positioning when\n          // the element is moved to be a child of the target's offset parent).\n          next.offset = {\n            top: next.page.top - offsetPosition.top + scrollTop - offsetBorder.top,\n            left: next.page.left - offsetPosition.left + scrollLeft - offsetBorder.left\n          };\n        }\n      }\n    }\n\n    // We could also travel up the DOM and try each containing context, rather than only\n    // looking at the body, but we're gonna get diminishing returns.\n\n    this.move(next);\n\n    this.history.unshift(next);\n\n    if (this.history.length > 3) {\n      this.history.pop();\n    }\n\n    if (flushChanges) {\n      flush();\n    }\n\n    return true;\n  }\n\n  // THE ISSUE\n  move(pos) {\n    if (!(typeof this.element.parentNode !== 'undefined')) {\n      return;\n    }\n\n    const same = {};\n\n    for (let type in pos) {\n      same[type] = {};\n\n      for (let key in pos[type]) {\n        let found = false;\n\n        for (let i = 0; i < this.history.length; ++i) {\n          const point = this.history[i];\n          if (typeof point[type] !== 'undefined' &&\n            !within(point[type][key], pos[type][key])) {\n            found = true;\n            break;\n          }\n\n        }\n\n        if (!found) {\n          same[type][key] = true;\n        }\n      }\n    }\n\n    let css = { top: '', left: '', right: '', bottom: '' };\n\n    const transcribe = (_same, _pos) => {\n      const hasOptimizations = typeof this.options.optimizations !== 'undefined';\n      const gpu = hasOptimizations ? this.options.optimizations.gpu : null;\n      if (gpu !== false) {\n        let yPos, xPos;\n        if (_same.top) {\n          css.top = 0;\n          yPos = _pos.top;\n        } else {\n          css.bottom = 0;\n          yPos = -_pos.bottom;\n        }\n\n        if (_same.left) {\n          css.left = 0;\n          xPos = _pos.left;\n        } else {\n          css.right = 0;\n          xPos = -_pos.right;\n        }\n\n        if (typeof window.devicePixelRatio === 'number' && devicePixelRatio % 1 === 0) {\n          xPos = Math.round(xPos * devicePixelRatio) / devicePixelRatio;\n          yPos = Math.round(yPos * devicePixelRatio) / devicePixelRatio;\n        }\n\n        css[transformKey] = `translateX(${xPos}px) translateY(${yPos}px)`;\n\n        if (transformKey !== 'msTransform') {\n          // The Z transform will keep this in the GPU (faster, and prevents artifacts),\n          // but IE9 doesn't support 3d transforms and will choke.\n          css[transformKey] += ' translateZ(0)';\n        }\n\n      } else {\n        if (_same.top) {\n          css.top = `${_pos.top}px`;\n        } else {\n          css.bottom = `${_pos.bottom}px`;\n        }\n\n        if (_same.left) {\n          css.left = `${_pos.left}px`;\n        } else {\n          css.right = `${_pos.right}px`;\n        }\n      }\n    };\n\n    const hasOptimizations = typeof this.options.optimizations !== 'undefined';\n    let allowPositionFixed = true;\n\n    if (hasOptimizations && this.options.optimizations.allowPositionFixed === false) {\n      allowPositionFixed = false;\n    }\n\n    let moved = false;\n    if ((same.page.top || same.page.bottom) && (same.page.left || same.page.right)) {\n      css.position = 'absolute';\n      transcribe(same.page, pos.page);\n\n    } else if (allowPositionFixed && (same.viewport.top || same.viewport.bottom) && (same.viewport.left || same.viewport.right)) {\n      css.position = 'fixed';\n      transcribe(same.viewport, pos.viewport);\n    } else if (typeof same.offset !== 'undefined' && same.offset.top && same.offset.left) {\n      css.position = 'absolute';\n      const offsetParent = this.cache('target-offsetparent', () => getOffsetParent(this.target));\n\n      if (getOffsetParent(this.element) !== offsetParent) {\n        defer(() => {\n          this.element.parentNode.removeChild(this.element);\n          offsetParent.appendChild(this.element);\n        });\n      }\n\n      transcribe(same.offset, pos.offset);\n      moved = true;\n\n    } else {\n      css.position = 'absolute';\n      transcribe({ top: true, left: true }, pos.page);\n    }\n\n    if (!moved) {\n      if (this.options.bodyElement) {\n        if (this.element.parentNode !== this.options.bodyElement) {\n          this.options.bodyElement.appendChild(this.element);\n        }\n      } else {\n        let offsetParentIsBody = true;\n\n        let currentNode = this.element.parentNode;\n        while (currentNode && currentNode.nodeType === 1 && currentNode.tagName !== 'BODY' && !isFullscreenElement(currentNode)) {\n          if (getComputedStyle(currentNode).position !== 'static') {\n            offsetParentIsBody = false;\n            break;\n          }\n\n          currentNode = currentNode.parentNode;\n        }\n\n        if (!offsetParentIsBody) {\n          this.element.parentNode.removeChild(this.element);\n          this.element.ownerDocument.body.appendChild(this.element);\n        }\n      }\n    }\n\n    // Any css change will trigger a repaint, so let's avoid one if nothing changed\n    const writeCSS = {};\n    let write = false;\n    for (let key in css) {\n      let val = css[key];\n      let elVal = this.element.style[key];\n\n      if (elVal !== val) {\n        write = true;\n        writeCSS[key] = val;\n      }\n    }\n\n    if (write) {\n      defer(() => {\n        extend(this.element.style, writeCSS);\n        this.trigger('repositioned');\n      });\n    }\n  }\n}\n\nTetherClass.modules = [];\n\nTetherBase.position = position;\n\nlet Tether = extend(TetherClass, TetherBase);\n\nTether.modules.push({\n  initialize() {\n    this.markers = {};\n\n    ['target', 'element'].forEach((type) => {\n      const el = document.createElement('div');\n      el.className = this.getClass(`${type}-marker`);\n\n      const dot = document.createElement('div');\n      dot.className = this.getClass('marker-dot');\n      el.appendChild(dot);\n\n      this[type].appendChild(el);\n\n      this.markers[type] = { dot, el };\n    });\n  },\n\n  position({ manualOffset, manualTargetOffset }) {\n    const offsets = {\n      element: manualOffset,\n      target: manualTargetOffset\n    };\n\n    for (let type in offsets) {\n      const offset = offsets[type];\n      for (let side in offset) {\n        let val = offset[side];\n        const notString = typeof val !== 'string';\n        if (notString ||\n          val.indexOf('%') === -1 &&\n          val.indexOf('px') === -1) {\n          val += 'px';\n        }\n\n        if (this.markers[type].dot.style[side] !== val) {\n          this.markers[type].dot.style[side] = val;\n        }\n      }\n    }\n\n    return true;\n  }\n});\n\nexport default Tether;\n"],"names":["TetherBase","Evented","on","event","handler","ctx","once","this","bindings","push","off","i","length","splice","trigger","args","context","apply","modules","zeroElement","getActualBoundingClientRect","node","boundingRect","getBoundingClientRect","rect","k","ownerDocument","document","frameElement","defaultView","frameRect","top","bottom","left","right","err","id","uniqueId","zeroPosCache","getOrigin","body","contains","createElement","setAttribute","extend","style","position","appendChild","getAttribute","defer","_scrollBarSize","out","Array","prototype","arguments","slice","forEach","obj","key","hasOwnProperty","call","removeClass","el","name","classList","split","cls","trim","remove","regex","RegExp","join","className","getClassName","replace","setClassName","addClass","add","hasClass","test","SVGAnimatedString","baseVal","deferred","fn","Utils","getScrollParents","getComputedStyle","parents","parent","parentNode","nodeType","overflow","overflowX","overflowY","indexOf","getBounds","doc","documentElement","docEl","box","origin","width","scrollWidth","height","scrollHeight","clientTop","clientLeft","clientWidth","clientHeight","getOffsetParent","offsetParent","updateClasses","all","flush","pop","getScrollBarSize","inner","outer","pointerEvents","visibility","widthContained","offsetWidth","widthScroll","removeChild","removeUtilElements","BOUNDS_FORMAT","targetAttachment","options","constraints","cache","_this","element","lastSize","targetSize","getTargetBounds","targetHeight","targetWidth","allClasses","getClass","constraint","outOfBoundsClass","pinnedClass","side","addClasses","tAttachment","eAttachment","attachment","changeAttachX","changeAttachY","to","pin","bounds","tether","scrollParents","pageXOffset","pageYOffset","innerWidth","innerHeight","size","pos","win","toUpperCase","substr","parseFloat","getBoundingRect","map","p","oobClass","pinned","oob","updateAttachClasses","addTargetClasses","target","targetPos","abutted","targetPosSide","shift","shiftTop","shiftLeft","lastCall","lastDuration","pendingTimeout","tick","transformKey","transforms","undefined","tethers","now","performance","Date","Math","min","setTimeout","clearTimeout","window","addEventListener","MIRROR_LR","center","MIRROR_TB","middle","OFFSET_MAP","attachmentToOffset","addOffset","offsets","offsetToPx","offset","parseOffset","value","parseAttachment","TetherClass","bind","history","setOptions","module","initialize","classes","classPrefix","targetOffset","targetModifier","_this2","Error","jquery","querySelector","disable","enabled","enable","scrollBottom","borderTopWidth","borderBottomWidth","borderLeftWidth","fitAdj","pow","max","scrollPercentage","scrollTop","clearCache","_cache","getter","_this3","removeEventListener","_this4","destroy","_this5","elementAttach","targetAttach","_addAttachClasses","_this6","flushChanges","relativeToAttachment","autoToFixedAttachment","elementPos","_this7","manualOffset","manualTargetOffset","ret","scrollbarSize","next","page","viewport","parentElement","optimizations","moveElement","offsetPosition","offsetParentStyle","offsetParentSize","offsetBorder","toLowerCase","scrollLeft","move","unshift","a","b","diff","same","type","found","point","within","css","transcribe","_same","_pos","yPos","xPos","_this8","gpu","devicePixelRatio","round","allowPositionFixed","e","d","moved","bodyElement","offsetParentIsBody","currentNode","tagName","fullscreenElement","webkitFullscreenElement","mozFullScreenElement","msFullscreenElement","writeCSS","write","val","Tether","markers","_this9","dot"],"mappings":"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"}